# åå°„

> æ¨èå­¦ä¹ ï¼š[ã€Golangã€‘å›¾è§£åå°„](https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==&mid=2247484172&idx=1&sn=06299f7bb8751e41d0395e565a919878&chksm=c005d30cf7725a1a8a3c7c6aade78b5041b8556b334994f737c88857959b625f844f5f9f76dd&scene=21#wechat_redirect)

## å‰è¨€

ç”¨åˆ°åå°„çš„åœºæ™¯ä¸å¤šï¼Œä¸€èˆ¬æ˜¯å˜é‡ç±»å‹ä¸ç¡®å®šï¼Œå†…éƒ¨ç»“æ„ä¸æ˜æœ—çš„æƒ…å†µï¼Œåæ­£æˆ‘ç°åœ¨ä¸€æ¬¡éƒ½æ²¡æœ‰ç”¨è¿‡ï¼Œä½†æ˜¯ä¸å¦¨ç¢æˆ‘ä»¬æ¥çœ‹çœ‹åº•å±‚åˆ°åº•æ˜¯æ€ä¹ˆå›äº‹ã€‚

`reflect` æœ‰ä¸¤ä¸ªæ ¸å¿ƒç±»å‹ï¼š`reflect.Type` å’Œ `reflect.Value`ã€‚ä»–ä»¬æ’‘èµ·äº†åå°„åŠŸèƒ½çš„åŸºæœ¬æ¡†æ¶ã€‚

## Type

`reflect.Type` æ˜¯ä¸€ä¸ªæ¥å£ç±»å‹ï¼Œå®šä¹‰äº†ä¸€ç³»åˆ—æ–¹æ³•è·å–ç±»å‹å„æ–¹é¢çš„ä¿¡æ¯ã€‚

```go
type Type interface {
    Align() int //å¯¹é½è¾¹ç•Œ
    FieldAlign() int //ä½œä¸ºç»“æ„ä½“å­—æ®µçš„å¯¹é½è¾¹ç•Œ
    Method(int) Method //è·å–æ–¹æ³•æ•°ç»„ä¸­ç¬¬iä¸ªMethod
    MethodByName(string) (Method, bool) //æŒ‰ç…§åç§°æŸ¥æ‰¾æ–¹æ³•
    NumMethod() int //æ–¹æ³•åˆ—è¡¨ä¸­å¯å¯¼å‡ºæ–¹æ³•çš„æ•°ç›®
    Name() string //ç±»å‹åç§°
    PkgPath() string //åŒ…è·¯å¾„
    Size() uintptr //è¯¥ç±»å‹å˜é‡å ç”¨å­—èŠ‚æ•°
    String() string //è·å–ç±»å‹çš„å­—ç¬¦ä¸²è¡¨ç¤º
    Kind() Kind //ç±»å‹å¯¹åº”çš„reflect.Kind
    Implements(u Type) bool //è¯¥ç±»å‹æ˜¯å¦å®ç°äº†æ¥å£u
    AssignableTo(u Type) bool //æ˜¯å¦å¯ä»¥èµ‹å€¼ç»™ç±»å‹u
    ConvertibleTo(u Type) bool //æ˜¯å¦å¯è½¬æ¢ä¸ºç±»å‹u
    Comparable() bool //æ˜¯å¦å¯æ¯”è¾ƒ

    //åªèƒ½åº”ç”¨äºæŸäº›Kindçš„æ–¹æ³•
    //Int*, Uint*, Float*, Complex*: 
    Bits() int

    //Array,Ptr,Slice,Map: 
    Elem() Type
    //Array
    Len() int
        
    //Chan:ChanDir, Elem 
    ChanDir() ChanDir

    //Func: 
    In(i int) Type
    NumIn() int
    Out(i int) Type
    NumOut() int
    IsVariadic() bool

    //Map: 
    Key() Type

    //Struct: 
    Field(i int) StructField
    FieldByIndex(index []int) StructField
    FieldByName(name string) (StructField, bool)
    FieldByNameFunc(match func(string) bool) (StructField, bool)  
    NumField() int

    common() *rtype
    uncommon() *uncommonType
}
```

æˆ‘ä»¬é€šå¸¸ä¼šç”¨ `reflect.TypeOf` è¿™ä¸ªå‡½æ•°å»æ‹¿åˆ° `reflect.Type` ç±»å‹çš„è¿”å›å€¼ã€

```go
// TypeOf è¿”å›è¡¨ç¤º i çš„åŠ¨æ€ç±»å‹çš„åå°„ç±»å‹ã€‚å¦‚æœ i æ˜¯ä¸€ä¸ª nil æ¥å£å€¼ï¼Œåˆ™ TypeOf è¿”å› nilã€‚
func TypeOf(i interface{}) Type {
	eface := *(*emptyInterface)(unsafe.Pointer(&i))
	return toType(eface.typ)
}
```

ä¸¾ä¸ªä¾‹å­ğŸŒ°ï¼š

```go
	a:="eggo"
	t:=reflect.TypeOf(a)
	fmt.Println(t.Name())
```

æˆ‘ä»¬è¦åå°„ `int` ç±»å‹çš„å˜é‡ `a`ã€‚

æˆ‘ä»¬ä¾æ—§ä»å‡½æ•°è°ƒç”¨æ ˆå¼€å§‹åˆ†æï¼Œ`main` å‡½æ•°æ ˆå¸§ä¸­æœ‰ä¸¤ä¸ªå±€éƒ¨å˜é‡ `t` ä¸ `a`ï¼Œç„¶åæ˜¯è¿”å›å€¼ç©ºé—´ï¼Œæœ€åæ˜¯å‚æ•°ã€‚æˆ‘ä»¬çŸ¥é“ `Go` è¯­è¨€ä¸­å‚æ•°éƒ½æ˜¯å€¼æ‹·è´ã€‚éš¾é“è¿™é‡Œå‚æ•°æ˜¯æ‹·è´å˜é‡ `a` çš„å€¼å—ï¼Ÿä¸è¡Œï¼Œ`TypeOf` å‡½æ•°çš„å‚æ•°ç±»å‹æ˜¯ç©ºæ¥å£ã€‚

```go
type eface struct {
    _type *_type //æŒ‡å‘æ¥å£çš„åŠ¨æ€ç±»å‹å…ƒæ•°æ® 
    data  unsafe.Pointer //æŒ‡å‘æ¥å£çš„åŠ¨æ€å€¼ã€‚ 
}
```

`_type` å­—æ®µæ¥å—çš„æ˜¯ `a` çš„åŠ¨æ€ç±»å‹ï¼Œ`data` æ¥å—çš„æ˜¯ `a` çš„åœ°å€ã€‚

**æ‹·è´ä¸äº†å€¼ï¼Œé‚£æ‹·è´å˜é‡ `a` çš„åœ°å€ï¼Ÿ**ä¹Ÿä¸è¡Œï¼Œå› ä¸ºè¿™æ ·å¹¶ä¸ç¬¦åˆ**`Go` è¯­è¨€ä¸­ä¼ å‚å€¼æ‹·è´**çš„è¯­ä¹‰ï¼Œæ— è®ºå¯¹å‚æ•°åšæ€ä¹ˆæ ·çš„ä¿®æ”¹ï¼Œéƒ½ä¸èƒ½ä½œç”¨åˆ°å±€éƒ¨å˜é‡ã€‚

**æ—¢ç„¶æ‹·è´ä¸äº†å€¼ï¼Œä¹Ÿä¸èƒ½æ‹·è´å€¼ï¼Œé‚£åº”è¯¥æ€ä¹ˆåŠï¼Ÿ**å®é™…ä¸Šåœ¨ç¼–è¯‘é˜¶æ®µä¼šå¢åŠ ä¸€ä¸ªä¸´æ—¶å˜é‡ä½œä¸º a çš„æ‹·è´å€¼ï¼ˆcopy of aï¼‰ï¼Œå†æŠŠè¿™ä¸ªä¸´æ—¶å˜é‡çš„åœ°å€ä¼ é€’ç»™å‡½æ•°ä½¿ç”¨ï¼Œè¿™æ ·æ— è®ºå‡½æ•°å¯¹å‚æ•°åšæ€ä¹ˆæ ·çš„ä¿®æ”¹ï¼Œéƒ½ä¸ä¼šä½œç”¨åˆ°å±€éƒ¨å˜é‡ aã€‚æ—¢æ»¡è¶³äº†ç©ºæ¥å£ç±»å‹çš„å‚æ•°ä¹Ÿç¬¦åˆä¼ å‚å€¼æ‹·è´çš„è¯­ä¹‰ã€‚

![å›¾ç‰‡](https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4H10TIVbNxnHRlUuh0icCFIFTLSBz1kfJ5uicMXqhEPv7S5VZR6Mqe39QWiceGfzicBMuwGfIEMSH46g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**å½“å‚æ•°æ˜¯ç©ºæ¥å£æƒ…å†µï¼Œéƒ½æ˜¯é€šè¿‡ä¼ é€’æ‹·è´åå˜é‡çš„åœ°å€æ¥å®ç°ä¼ å€¼çš„è¯­ä¹‰ã€‚**

æ¥ä¸‹æ¥ï¼Œ`reflect.TypeOf` å‡½æ•°ä¼šæŠŠ `runtime.eface` ç±»å‹çš„å‚æ•° `i` è½¬åŒ–æˆ `reflect.emptInterface` ç±»å‹å¹¶èµ‹ç»™å˜é‡ `eface`ï¼Œè½¬æ¢ä»¥åæ–¹ä¾¿ `reflect` åŒ…æ“ä½œå†…éƒ¨å…ƒç´ ã€‚

```go
// emptyInterface æ˜¯ interface{} å€¼çš„æ ‡å¤´ã€‚
type emptyInterface struct {
	typ  *rtype //string
	word unsafe.Pointer //->i.data
}
```

å› ä¸º `*rtype` å®ç°äº† `reflect.Type` æ¥å£ï¼Œ`TypeOf` å‡½æ•°è¦åšçš„å°±æ˜¯æŠŠ `eface` çš„ `typ` å­—æ®µå–å‡ºæ¥ï¼ŒåŒ…è£…æˆ `reflect.Type` ç±»å‹çš„è¿”å›å€¼å°±å¯ä»¥äº†ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ `toType` å‡½æ•°å¹²çš„æ´»

```go
func toType(t *rtype) Type {
	if t == nil {
		return nil
	}
	return t
}
//ä¸Šé¢çš„ä»£ç å¯ä»¥ç­‰ä»·äº
var ret reflect.Type
ret = eface.typ
```

`reflect.Type` æ—¢ç„¶æ˜¯ä¸€ä¸ªéç©ºæ¥å£ï¼Œé‚£ä¹ˆä»–çš„ç»“æ„å¦‚ä¸‹ï¼š

```go
type iface struct {
    tab   *itab
    data  unsafe.Pointer //æ¥å£çš„åŠ¨æ€å€¼ ->eface.typ
}
//itab
type itab struct {
    inter  *interfacetype //æ¥å£çš„ç±»å‹å…ƒæ•°æ®  ->reflect.Type
    _type  *_type //æŒ‡å‘æ¥å£çš„åŠ¨æ€ç±»å‹å…ƒæ•°æ® ->*rtype
    hash   uint32 //itab._typeä¸­æ‹·è´æ¥çš„ï¼Œç±»å‹å“ˆå¸Œå€¼
    _      [4]byte
    fun    [1]uintptr //åŠ¨æ€ç±»å‹å®ç°çš„æ¥å£è¦æ±‚æ–¹æ³•åœ°å€ 
}
```

é‚£ä¹ˆæœ€åè¿”å›å€¼çš„ç»“æ„å°±ä¸ `iface` ç»“æ„å·®ä¸å¤šï¼Œ`tab` æŒ‡å‘ `<reflect.Typeï¼Œ*rtype>` å¯¹åº”çš„ `itab` æŒ‡é’ˆï¼Œ`data` åˆ™æ˜¯å˜é‡ `a` çš„åœ°å€ã€‚

æ¥ä¸‹æ¥é€šè¿‡éç©ºæ¥å£ç±»å‹ `t` å»è°ƒç”¨å„ç§æ–¹æ³•éƒ½ä¼šå» `string` ç±»å‹æŸ¥æ‰¾ç›¸å…³æ•°æ®ã€‚

## Value

`reflect.Value` æ˜¯ä¸€ä¸ªç»“æ„ä½“ç±»å‹ã€‚

```go
type Value struct {
    typ *rtype //å­˜å‚¨åå°„å˜é‡çš„ç±»å‹å…ƒæ•°æ®æŒ‡é’ˆ
    ptr unsafe.Pointer //å­˜å‚¨æ•°æ®åœ°å€
    flag //æ˜¯ä¸€ä¸ªä½æ ‡è¯†ç¬¦ï¼Œå­˜å‚¨åå°„å˜é‡å€¼çš„ä¸€äº›æè¿°ä¿¡æ¯ï¼Œä¾‹å¦‚ç±»å‹æ©ç ï¼Œæ˜¯å¦ä¸ºæŒ‡é’ˆï¼Œæ˜¯å¦ä¸ºæ–¹æ³•ï¼Œæ˜¯å¦åªè¯»ç­‰ç­‰
}
```

æˆ‘ä»¬æ¥çœ‹çœ‹åå°„æ˜¯å¦‚ä½•æ›´æ–°å˜é‡å€¼çš„ï¼

ä¸¾ä¸ªä¾‹å­ğŸŒ°ï¼š

```go
	a := "eggo"
	v := reflect.ValueOf(a)
	v.SetString("new eggo")
	println(a)
//panic: reflect: reflect.Value.SetString using unaddressable value
```

æˆ‘ä»¬æ¥çœ‹çœ‹ `reflect.ValueOf` å‡½æ•°æ˜¯æ€ä¹ˆæ ·çš„ï¼

```go
func ValueOf(i interface{}) Value {
	if i == nil {
		return Value{}
	}
	escapes(i)

	return unpackEface(i)
}

func escapes(x interface{}) {
	if dummy.b {
		dummy.x = x
	}
}
```

ä»–çš„å‚æ•°æ˜¯ç©ºæ¥å£ç±»å‹ï¼Œæ‰€ä»¥æ¥å—çš„å‚æ•°æ•°æ®æ˜¯å˜é‡ `a` çš„æ‹·è´å€¼åœ°å€ã€‚

```go
type eface struct {
    _type *_type //æŒ‡å‘æ¥å£çš„åŠ¨æ€ç±»å‹å…ƒæ•°æ®  ->stringtype
    data  unsafe.Pointer //æŒ‡å‘æ¥å£çš„åŠ¨æ€å€¼ã€‚  ->&(copy of a)
}
```

æ ¹æ®ä»£ç æ³¨é‡Šï¼Œ`escapes` å‡½æ•°ä¼šæŠŠå‚æ•° `i` æŒ‡å‘å¾—å˜é‡ï¼ˆå˜é‡ `a` å¾—æ‹·è´å€¼ `copy of a`ï¼‰é€ƒé€¸åˆ°å †ä¸Šï¼Œé‚£ä¹ˆæ ˆä¸Šåªä¼šç•™ä¸‹ä»–ï¼ˆ`copy of a`ï¼‰çš„åœ°å€ã€‚

![å›¾ç‰‡](https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4H10TIVbNxnHRlUuh0icCFIFEQaAmVKibOx4FpMYRu8tMdMziay6s3xiaaWG4jDSMdwzG4b3OIMPKsMQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```go
func unpackEface(i interface{}) Value {
	e := (*emptyInterface)(unsafe.Pointer(&i))
	// NOTE: don't read e.word until we know whether it is really a pointer or not.
	t := e.typ
	if t == nil {
		return Value{}
	}
	f := flag(t.Kind())
	if ifaceIndir(t) {
		f |= flagIndir
	}
	return Value{t, e.word, f}
}
```

ç®€å•çœ‹è¿™ä¸ªå‡½æ•°é€»è¾‘ã€‚`ValueOf` å‡½æ•°çš„è¿”å›å€¼æ˜¯ `reflect.Value` ç±»å‹ï¼Œè¿”å›å€¼ç»“æ„å¦‚ä¸‹ï¼š

```go
type Value struct {
    typ *rtype //å­˜å‚¨åå°„å˜é‡çš„ç±»å‹å…ƒæ•°æ®æŒ‡é’ˆ  ->å°±æ˜¯å‚æ•°çš„ _type
    ptr unsafe.Pointer //å­˜å‚¨æ•°æ®åœ°å€ ->&(copy of a) æ ¹æ® unpackEface æ¥çœ‹å®ƒæ¥è‡ªäº emptyInterface.word å†å¾€å‰çœ‹ å…¶å®æ¥è‡ªäº å‚æ•°çš„ data å­—æ®µ
    flag //æ˜¯ä¸€ä¸ªä½æ ‡è¯†ç¬¦ï¼Œå­˜å‚¨åå°„å˜é‡å€¼çš„ä¸€äº›æè¿°ä¿¡æ¯ï¼Œä¾‹å¦‚ç±»å‹æ©ç ï¼Œæ˜¯å¦ä¸ºæŒ‡é’ˆï¼Œæ˜¯å¦ä¸ºæ–¹æ³•ï¼Œæ˜¯å¦åªè¯»ç­‰ç­‰
}
```

è¿™ä¸ªè¿”å›å€¼ä¼šè¢«èµ‹å€¼ç»™å±€éƒ¨å˜é‡ `v`ï¼Œè°ƒç”¨ `SetString` ã€‚

```go
func (v Value) SetString(x string) {
	v.mustBeAssignable()
	v.mustBe(String)
	*(*string)(v.ptr) = x
}
```

`SetString` å‡½æ•°ä¼šç”¨åˆ° `Value` ç±»å‹çš„ `ptr` å­—æ®µã€‚ä½†æ˜¯ç»è¿‡è¿”å›å€¼èµ‹å€¼å±€éƒ¨å˜é‡ `v` ä»–çš„å­—æ®µ `ptr` å¥½åƒæŒ‡å‘çš„æ˜¯ `&(copy of a)`ï¼Œè¿™æ˜¯ä¸´æ—¶å˜é‡çš„åœ°å€ï¼Œä¸èƒ½ä¿®æ”¹çš„ã€‚æ‰€ä»¥å°±ä¼šæŠ¥é”™ã€‚

å› ä¸ºä¿®æ”¹è¿™æ ·ä¸€ä¸ªè¿ç”¨æˆ·éƒ½ä¸çŸ¥é“çš„ä¸´æ—¶å˜é‡æ˜¯æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼ŒåŒæ—¶æˆ‘ä»¬çš„æœ¬æ„æ˜¯è¦ä¿®æ”¹å±€éƒ¨å˜é‡ `a`ï¼Œæ‰€ä»¥å°±ä¼šå‘ç”Ÿ `panic`ã€‚

```go
panic: reflect: reflect.Value.SetString using unaddressable value
```

å¥½åƒè¿™æ ·å­å»ä¿®æ”¹ä¸ç¬¦åˆè¦æ±‚å•Šï¼

æˆ‘ä»¬å›å¿†ä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆä¼šå‘ç”Ÿ `panic`ï¼Ÿæˆ‘ä»¬ä»åé¢ä¸€æ­¥ä¸€æ­¥ç†ä¸€ä¸‹ï¼Œå¤±è´¥åŸå› ã€‚

* v çš„å­—æ®µ ptr æŒ‡å‘æ˜¯ `&(copy of a)`
* ä¸ºä»€ä¹ˆä¼šæœ‰è¿™ä¸ª `&(copy of a)`ï¼Ÿå› ä¸ºä¼ å‚ä¼ çš„æ˜¯å±€éƒ¨å˜é‡ `a`ï¼Œä¸ºäº†æ»¡è¶³è¯­ä¹‰ã€‚

æˆ‘ä»¬ç°åœ¨æ˜ç™½äº†ï¼Œè¦æƒ³å»ä¿®æ”¹å˜é‡ `a`ï¼Œéœ€è¦åå°„ `a` çš„æŒ‡é’ˆï¼Œåªæœ‰è¿™æ · `ptr` æ‰ä¼šæŒ‡å‘ `&a`ã€‚

ä¸¾ä¸ªä¾‹å­ğŸŒ°ï¼š

```go
func main() {
    a := "eggo"
    v := reflect.ValueOf(&a)
    v.Elem().SetString("new eggo")
    println(a)
}
```

è¿™é‡Œä¼ å‚ä¾æ—§æ˜¯å€¼æ‹·è´ï¼Œè¿™æ¬¡æ‹·è´ `a` çš„åœ°å€ï¼Œ`escapes` ä¼šå°†å‚æ•°æŒ‡å‘çš„å˜é‡ `a` é€ƒé€¸åˆ°å †ä¸Šï¼Œé‚£ä¹ˆæ ˆä¸Šåªå­˜ä»–çš„åœ°å€ `&a`ã€‚

![å›¾ç‰‡](https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L4H10TIVbNxnHRlUuh0icCFIdPficCgTms7VHL5wdicbKqSjtevM1Jc0rs9pFTvr1ejgLpqfXnbqNwQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

å‰©ä½™çš„éƒ¨åˆ†ä¸ä¸Šé¢é‚£ä¸ªä¾‹å­ç±»ä¼¼ï¼Œå°±ä¸è¿‡å¤šçš„æè¿°äº†ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ä¸åŒçš„åœ°æ–¹ã€‚

é€šè¿‡è°ƒç”¨ `v.Elem()` æ–¹æ³•ç„¶åï¼Œå†è°ƒç”¨çš„çš„ `SetString` æ–¹æ³•å°±å¯ä»¥ä¿®æ”¹åŸæ¥çš„å˜é‡ `a`äº†ã€‚

ä¸ºä»€ä¹ˆä¸€å®šè¦å…ˆè°ƒç”¨ `Elem` æ‹¿åˆ° `ptr` å†å»ä¿®æ”¹å€¼å‘¢ï¼Ÿ

```go
func (v Value) Elem() Value {
	k := v.kind()
	switch k {
	case Interface:
		var eface interface{}
		if v.typ.NumMethod() == 0 {
			eface = *(*interface{})(v.ptr)
		} else {
			eface = (interface{})(*(*interface {
				M()
			})(v.ptr))
		}
		x := unpackEface(eface)
		if x.flag != 0 {
			x.flag |= v.flag.ro()
		}
		return x
	case Ptr:
		ptr := v.ptr
		if v.flag&flagIndir != 0 {
			ptr = *(*unsafe.Pointer)(ptr)
		}
		// The returned value's address is v's value.
		if ptr == nil {
			return Value{}
		}
		tt := (*ptrType)(unsafe.Pointer(v.typ))
		typ := tt.elem
		fl := v.flag&flagRO | flagIndir | flagAddr
		fl |= flag(typ.Kind())
		return Value{typ, ptr, fl}
	}
	panic(&ValueError{"reflect.Value.Elem", v.kind()})
}
```



```go
func (v Value) SetString(x string) {
	v.mustBeAssignable()
	v.mustBe(String)
	*(*string)(v.ptr) = x
}
```




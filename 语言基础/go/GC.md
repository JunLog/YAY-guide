## GC（Garbage Collection）

> 推荐阅读：
>
> [粗线条话GC（一）](https://mp.weixin.qq.com/s?__biz=Mzg5NjIwNzIxNQ==&mid=2247484496&idx=1&sn=c7555433941ff4698f1cc7fcb2a5fedd&chksm=c005d450f7725d462dcf05d8bad834485703f1da34ee174fd5aaedc09da4c7bf821e06bdaf7c&scene=21#wechat_redirect)

## 为什么会有GC存在

在我们之前就了解到，程序定义的全局变量，常量等都会分配到数据段中，而函数的局部变量，参数，返回值都会分配到函数调用栈上。那些生命周期超过当前函数的数据，例如闭包的可变变量，还有一些编译阶段不能确定大小的数据，例如反射，都不适合分配到栈上，都会被分配到堆上，在栈上使用其堆上的地址。

随着程序的运行，慢慢的有些数据不会被再次使用，那么为了减少内存，选择回收。

那么回收哪一部分的数据呢？

分配到栈上的数据，他会随着函数调用栈的销毁也会释放自己的内存，所以不用回收这一部分的。

分配到堆上的数据，他们好像没有人对他处理，如果存在时间长了，对于程序就是一种垃圾了，需要回收这一部分的数据。

## 回收方式

### 手动回收

有些编程语言需要程序员在编写程序时候，手动释放那些不需要的，分配到堆上的数据。例如（C/C++）

缺点：

> 手动垃圾回收不仅增加编程负担，而且风险还比较高。一旦释放的早了，后续对该数据的访问就会出错。因为被释放的内存可能已经被清空，或重新分配，甚至已经还给操作系统了，这就是所谓的“悬挂指针”问题；而如果忘了释放，它又会一直占用内存，出现“内存泄漏”。

### 自动回收

越来越多的编程语言已经支持“自动垃圾回收”，包括 `Go` 语言。

会自动解决由运行时候识别不再有用的数据并释放，存何时被释放，被释放的内存如何处理等问题。

我们今天就来看看，自动垃圾回收到底是怎么样的。

## 什么是垃圾

> 你是垃圾吗？

怎么去区分这个数据是**有用的数据**还是**垃圾**呢？

我们可以确定，程序中用的到的数据，一定是在栈，数据段上存储的数据。也就是说，可以以这些地方的数据作为根节点，可以追踪的范围一定都包含了全部有用的数据。

那么既然追踪不到的的数据，就一定用不到，就是垃圾。

这是**数据的可达性**！

目前主流的垃圾回收算法都是**使用数据“可达性”近似等价于数据有用性的**。

但是能够追踪到的数据不一定是有用！这也为什么是**近似**的原因。这个数据很少，所以可以进行忽略。

### 标记+清扫

我们通过标记方法，去区分数据的有用性。

**三色抽象**可以清晰的展现追踪过程中的数据标记的变化：

1. 垃圾回收开始会把所有的数据都标记为白色
2. 能够直接追踪到的 `root` 节点标记成灰色。灰色代表当前节点展开的追踪还未完成。
3. 当当前的节点的追踪任务完成后，会将该节点标记成黑色。代表此数据是有用的数据，无需再次进行追踪。
4. 当没有灰色节点时候，代表标记工作已完成。
5. 现在有用的数据都是黑色了，垃圾数据则是白色，那么接下来肯定是清除白色的数据。

三色标记法的三色：

* 黑色（Black）：表示对象是 `GC Root` 可达的，即使用中的对象，黑色是“已经被扫描的对象”。
* 灰色（Grey）：表示黑色对像可追踪到的，但还没对它进行扫描。
* 白色（White）：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/ibjI8pEWI9L7ryNA4xyYh7cDaEAFdDHibXVlsU7ic2IyvfAWpd01OlqMdaict6qL954HBMVNv2SJIxuhe0OReOWF7Q/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

优点：

* 实现简单
* 三色标记法的标记过程可以增量式（Incremental）地运行（异步执行）

缺点：

* 容易造成内存碎片化，内存碎片化会影响内存分配与程序执行的效率

### 标记+压缩

这里压缩目的与清扫一直都是回收垃圾，但是这里的行为不一样，移动那些有用数据块，达到压缩的效果。

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L7ryNA4xyYh7cDaEAFdDHibXqdCmiaZ8icQclsN0BUSXcDWmCTWMoG3kahdOibagzib5lOksZKsPtOdf0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



优点：

* 解决了内存碎片化的问题

缺点：

* 多次扫描与移动数据块的开销巨大。

> 推荐文章：
>
> [垃圾回收(GC)算法介绍(4)——GC标记-压缩算法](https://nullcc.github.io/2017/11/30/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(GC)%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D(4)%E2%80%94%E2%80%94GC%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/)

### 标记+复制式回收

回收过程：

1. 首先将堆内存划分成两个相等的空间，`FROM&TO`。程序执行时候使用 `FROM` 空间
2. 当要进行垃圾回收时候，扫描 `FROM` 空间，将可以追踪到数据复制到 `TO` 空间。
3. 当所有可追踪数据都复制到 `TO` 空间时候，就可以将 `FROM` 和 `TO` 空间进行交换。简单来讲就是负责的功能进行了交换。

优点：

* 解决了碎片化问题
* 使用连续的内存块，可以实现高速的内存分配。

缺点：

* 只有一半的堆内存可以使用，降低了堆内存的使用率。

### 标记+分代回收

新生代对象：新创建的对象

老年代对象：经受住特定次数的垃圾回收而依然存活的对象

基于弱分代假说，新生代对象成为垃圾的概率高于老年代对象，所以可以把数据划分为新生代和老年代，降低老年代执行垃圾回收的频率。

优点：

* 不用每次都扫描所有数据，将明显提升垃圾回收执行的效率，
* 新生代和老年代还可以分别采用不同的回收策略，进一步提升回收效益并减少开销。

缺点：

* 写入屏障会对指针更新操作带来额外的负担。
* 另外如果一个程序中大部分对象存活时间都很长的话，会增加新生代 `GC` 的压力，并且导致老年代 `GC` 频繁地运行。

### 标记+引用计数

一个数据对象被引用的次数，程序执行过程中会更新对象及子对象的引用次数。当引用次数更新到0时候，就代表这个对象是垃圾了，可以进行回收了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/ibjI8pEWI9L7ryNA4xyYh7cDaEAFdDHibXWzGlRLywETdC0ickFJqSZlIMpJNkiaOuiaqlUAjlIMgoZEZSkoh3FSD5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

优点：

* 不用专门去执行扫描任务，垃圾识别的任务已经分摊到每次数据对象的操作

缺点：

* 实现困难
* 高频率的更新引用会带来不小的开销
* 需要专门解决循环引用的情况。因为循环引用会导致引用计数无法更新到0，造成对应的内存无法被回收的情况。

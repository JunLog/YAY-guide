# 数组与Slice原理

## 数组

数组是一个具有固定长度且拥有0个或者多个相同数据类型元素的序列。

数组的每一个元素都是通过索引去访问的，索引从0到数组长度减一。Go内置的函数`len`可以返回数组中元素个数。

```go
package main

import "fmt"

func main(){
	var a [3]int
	b:=[3]int{1,2,3}
	c:=[...]int{1,2,3}
	d:=[...]int{9:-1}
	fmt.Println("a:",a)
	fmt.Println("b:",b)
	fmt.Println("c:",c)
	fmt.Println("d:",d)
}
```

![image-20211024192051643](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20211024192051.png)

默认情况下，声明一个数组`var a [3]int` ,元素的初始化值是元素类型的零值。（对于`int`,对应的零值就是0）

同时可以使用数组字面量根据一组值来初始化一个数组（`b:=[3]int{1,2,3}`）。

如果省略号`...`代替数组长度，那么数组长度由初始化数组的元素个数决定。（`c:=[...]int{1,2,3}` 长度为3）

**数组长度是数组类型的一部分。**

那么`[3]int`和`[4]int`是两个不同的数组类型。**数组长度必须是常量表达式。**

同时组值可以具有索引和索引对应的值`d:=[...]int{9:-1}`,定义了一个拥有10个元素的数组d，最后一个元素值为-1，其余都是0值。



当函数参数传入的是一个数组时候，传入的参数都会创建一个副本，然后赋值给对应的函数变量。Go中**把数组看作是值传递**，而在其他语言当中，数组是**隐式的引用传递。**

```go
func test1() {
	arrayA := [2]int{100, 200}
	var arrayB [2]int

	arrayB = arrayA

	fmt.Printf("arrayA : %p , %v\n", &arrayA, arrayA)
	fmt.Printf("arrayB : %p , %v\n", &arrayB, arrayB)

	testArray(arrayA)
}

func testArray(x [2]int) {
	fmt.Printf("func Array : %p , %v\n", &x, x)
}
```

![image-20211024194617478](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20211024194617.png)

可以看到，三个内存地址都不同，这也就验证了 Go 中数组赋值和函数传参都是值复制的。

> ❓：那么这会导致什么问题？

假想每次传参都用数组，那么每次数组都要被复制一遍。如果数组大小有 100万，在64位机器上就需要花费大约 800W 字节，即 8MB 内存。这样会消耗掉大量的内存。

> ❗：解决方案之一：

使用数组指针，同时也允许被调函数修改调用方数组中的元素。但是也有缺点：数组本身是不可变的，无法为数组添加和删除元素。



> 💡：由于数组长度不可变的特性等原因，除在特殊情况下，很少使用数组，一般使用`Slice`

## 切片

`slice` 表示一个拥有相同类型元素的可边长度的序列。

用切片解决上面那个问题，那么切片的优势也会表现出来。

**用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。切片是引用传递，所以它们不需要使用额外的内存并且比使用数组更有效率。**


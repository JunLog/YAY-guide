# 函数调用栈

我们按照编程语言的语法定义的函数，会被编译器编译为一堆堆机器指令，写入可执行文件。程序执行时可执行文件被加载到内存，这些机器指令对应到虚拟地址空间中，位于代码段。

如果在一个函数中调用另一个函数，编译器就会对应生成一条**call**指令，程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条**ret**指令，负责在函数结束后跳回到调用处，继续执行。（如果学过微机原理，你可以懂得指令的含义）

## 函数栈帧

函数执行时候，需要有足够的内存空间，供他存放局部变量，参数等数据，这段空间对应到虚拟地址空间的栈。

分配给函数的栈空间被称为**函数栈帧**，Go 语言中函数栈帧布局是如下的，先是调用者栈基地址，然后是函数的局部变量，最后是被调用函数的返回值和参数。

![image-20211123203550591](https://cdn.jsdelivr.net/gh/baici1/img-typora/20211123203550.png)

> 注： bp 栈基不一定存在，在有些情况下会被优化掉，也有可能是平台不支持。我们只关注局部变量，返回值的相对位置就好了。

举个例子：

```go
func A() {
    var a1, a2, r1, r2 int64
    a1, a2 = 1, 2
    r1, r2 = B(a1, a2)
    r1 = C(a1)
    println(r1, r2)
}
func B(p1, p2 int64) (int64, int64) {
    return p2, p1
}
func C(p1 int64) int64 {
    return p1
}
```

函数 A 的栈帧分布就由上至下，分别是局部变量 `a1, a2, r1, r2` ，被调函数 B 的返回值 `r2,r1` ，被调用函数 B 的参数 `a2,a1`。

**注意观察参数的顺序，返回值和参数都是先入栈的第二个，然后再入栈的第一个，相当于是从右至左逐一入栈的。**

被调用函数是通过栈指针加上偏移量这样相对寻址的方式来定位自己的参数和返回值，刚好由下至上先找到第一个参数在找到第二个参数（通过**增加偏移量**的方式）。所以说参数和返回值采用**由右至左的入栈顺序**比较合适。

> 通常，我们认为返回值是通过寄存器传递的，但是 Go 语言支持多返回值，所以在栈上分配返回值空间更合适

**所有的函数的栈帧布局都会遵循统一的约定。**

对于函数 B 的调用会被编译器编译成 `Call` 指令。`Call` 指令只做两件事情。

1. 将下一条指令的地址入栈，被调用函数结束后，跳回到该地址继续执行，这就是返回地址
2. 跳转到被调用函数的指令入口处执行，所以返回地址下面就是函数 B 的栈帧。

其余的部分会按照 A 函数布局一样布局。

当函数 B 执行结束后会释放栈帧，然后就到 `Ret` 指令了，`Ret` 指令也会干两件事。

1. 弹出`Call` 指令压栈的返回地址
2. 跳转到返回地址

> 函数通过 `Call` 指令实现跳转，每个函数会分配栈帧，结束前就会释放自己的栈帧，`Ret` 指令就会将栈恢复到 `Call` 之前的样子。

那么函数 C 就是重复函数 B 的行为。

![image-20211123205624277](https://cdn.jsdelivr.net/gh/baici1/img-typora/20211123205624.png)

在 Go 语言中，函数栈帧是**一次性分配**的，也就是在函数开始执行时候分配足够大的栈帧空间。

一次性分配函数栈帧的主要原因是**避免栈访问越界**。如下图所示，三个 `goroutine` 初始化分配的栈空间是一样的。如果 `g2` 剩余的栈空间不够执行接下来的函数，如果选择**逐步扩张**，那么执行期间就会**发生栈访问越界**的情况。

![image-20211123210314416](https://cdn.jsdelivr.net/gh/baici1/img-typora/20211123210314.png)

其实对于栈消耗较大的函数，Go 语言编译器会在**函数头部插入检测代码**，如果发现需要**栈增长**，就会另外分配一个**足够大的栈空间**，将原来栈上的数据都拷过来，原来的空间就会被释放。

## 传参

我们在学习 C 语言时候相信也会遇到一个问题 `Swap` 为什么传参就无法交换变量，而交换指针时候却可以了。我会有很多解决，例如：实参和形参不在同一个地址，改变形参不会影响到实参。现在我们通过函数调用栈，来看看为什么会失败？传指针为什么会成功？

```go
func swap(a,b int) {
	a,b = b,a
}

func main() {
	a,b := 1,2
	swap(a,b)
	println(a,b)  //1,2
}
```

首先分析 `main` 函数的函数调用栈。



## 参考文章

[【Golang】图解函数调用栈](https://mp.weixin.qq.com/s/zcqzarXMJrDUY5DLXZXY1Q)

# 计算机网络面试题汇总

## OSI 与 TCP/IP篇

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911124706.gif)

### 1.OSI模型或者TCP/IP模型各层的功能,都有哪些协议?

 **物理层**

> 实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异（比特流）

**数据链路层**

> 建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现就直接丢弃。(帧)

 **网络层**

> 选择合适的网间路由和交换结点， 确保数据及时传送。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP（分组或者包）

**传输层**

> 负责向两台主机进程之间的通信提供通用的数据传输服务。协议有：TCP UDP，

**会话层**

> 建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话

 **表现层**

> 数据的表示、安全、压缩。格式有，JPEG、ASCll、DECOIC、加密格式等

 **应用层**

> 通过应用进程间的交互来完成特定网络应用，协议有：HTTP FTP TFTP（文件传输） SMTP（电子邮件传输） SNMP（网络管理） DNS（域名系统） TELNET（远程登录） HTTPS  DHCP（动态主机配置）

**至于tcp/ip模型你选择OSI模型对应的层去说即可**

![五层体系结构](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911134031.png)

七层模型传输数据过程：

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911131915.webp)

### 2.为什么要分层，分层有什么意义？

> 1. 各层之间是独立的。某一层可以使用其下一层提供的服务而不需要知道服务是如何实现的。
>
> 2.  灵活性好。当某一层发生变化时，只要其接口关系不变，则这层以上或以下的各层均不受影响。
>
> 3.  结构上可分割开。各层可以采用最合适的技术来实现 
>
> 4. 易于实现和维护。 
>
> 5. 能促进标准化工作。
>
>    与分层体系结构的思想相似的日常生活有邮政系统，物流系统。

## TCP篇

### 1.什么是TCP

> TCP是**面向连接的，可靠的，基于字节流**的传输层通信协议

面向连接的：

>  ⼀定是**「⼀对⼀」**才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀ 对多是⽆法做到的；

可靠的：

> ⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；

基于字节流：

>  消息是**「没有边界」**的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是**「有序的」**，当 **「前⼀个」**消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对**「重复」**的报⽂会⾃动丢弃。

### 2.TCP的头格式是什么？

​																						**TCP头部格式**

![image-20210911140927364](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911140927.png)

**序列号（seq）**：

> 在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据字节数」的⼤⼩。
>
> **用来解决⽹络包乱序问题**。

**确认应答号（ack）**：

> 指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。
>
> **用来解决不丢包的问题。**

控制位：

> * ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必 须设置为 1 。
>
> * RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
>
> * SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。 
>
> * FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

### 3.为什么需要TCP协议，他工作在哪一层？

> 网络层是**不可靠**的，他不能保证网络包的**按序交付**，也不能保证**网络包中的数据完整性**！所以就有传输层的**TCP协议**负责网络数据包的可靠性！

### 4.tcp是面向连接的，那么怎么确认是唯一的连接？

* 源地址
* 目的地址
  * 通过ip协议发送报文给对方主机
* 源端口
* 目的端口
  * 告诉TCP协议应该把报文发送给哪一个进程

### 5.传输层有TCP与UDP协议，他们之间区别是什么，分别应用的场景是哪儿？

**TCP与UDP区别：**

1. 连接
   * TCP是面向连接的，传输数据首先要**建立连接**，
   * UDP**不需要建立连接**，即刻传输数据
2. 服务对象
   * TCP协议是一对一传输
   * UDP是可以一对一，一对多，多对多的交互通信
3. 可靠性
   * TCP是可靠交付数据的，数据无差错，不丢失，不重复，按需到达
   * UDP尽最大努力交付，不能保证可靠性
4. 首部开销
   * TCP首部长度较长一般是20字节
   * UDP首部只有8个字节，固定不变，开销小
5. 传输方式
   * TCP 是流式传输，没有边界
   * UDP是一个一个包传输的，有边界

**TCP与UDP应用的场景：**

TCP是面向连接的，具有可靠性的，经常用于

* FTP文件传输
* HTTP/HTTPS
* SMTP邮件传输

UDP是不需要连接，尽最大努力交付的，经常用于：

* 视频，音频等多媒体通信
* 游戏网络通信
* 广播通信

### 6.简述TCP三次握手的过程

TCP 通过**三次握手**来建立连接

![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911145410.png)

**三次握手**过程如下：

* 一开始，客户端和服务端都处于`CLOSED`
* 先是服务端主动监听某个端口，处于`LISTEN` ,开始接受第一个报文
* 客户端随机初始化序列号（**client_isn**），同时控制位中的`SYN`置为1。第一个报文发送到服务端，表示向服务端发起连接请求，之后客户端处于`SYN-SENT`状态
* 服务端收到报文后，服务端随机初始化序列号（**server_isn**）,确认应答号（**ack**）填入`client_isn+1` 接着`SYN`和`ACK` 都置为1，发送报文到客户端，该报文不包含应用层数据，之后服务端处于`SYN-RCVD`状态
* 客户端收到报文后，还要向服务端回应一个应答报文，`ACK`置为1 ，确认应答号（**ack**）填入`server_isn+1` ，序列号可以填入应用层的数据，之后客户端处于`ESTABLISHEN`状态
* 服务器收到客户端的应答报文后，也进入`ESTABLISHED`状态

**温馨提示**：

> 第三次握手是可以携带数据的，前面两次的序列号都随机生成，不可以携带数据

**那么为什么前两次不能携带数据？**

> 减少服务器被攻击的风险。如果前两次能够携带数据，一旦有人想要攻击服务器，就可以在第一次握手中的SYN的报文放入大量数据，服务器势必会消耗更多的时间和内存空间去处理这些数据，就增加了服务器被攻击的风险。
>
> 第三次握手，客户端已经处于`ESTABLISHED`状态，可以接受服务器的报文，相对安全

参考博客：

https://blog.csdn.net/King___Ding/article/details/114873086

### 7.为什么是三次握手，不是两次，或者四次呢？

比较常回答的是“因为三次握⼿才能保证双⽅具有接收和发送的能⼒。”

但是这回答比较片面，，没有说到点子上，面试官不愿听

接下来以三个方面分析三次握手的原因：

* **三次握⼿才可以阻⽌重复历史连接的初始化**（主要原因）
* **三次握⼿才可以同步双⽅的初始序列号**
* **三次握⼿才可以避免资源浪费**

**原因一：避免历史连接**

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912120023.png)



三次握手的**首要原因是为防止旧的重复连接引起连接初始化混乱的问题。**

三次握手避免历史连接过程如下：

* 一个**旧的SYN报文**会比**新的SYN报文**先到服务端
* 服务端返回一个`SYN+ACK`报文到客户端
* 客户端通过自身的上下文,判断此连接是否是一个历史连接？
  * 如果是，客户端返回一个`RET`报文，终止此次连接，等待正确的SYN+ACK报文
  * 如果不是，则建立连接

> 如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送⽅）准备发送第三次 报⽂时，客户端因有足够的上下文来判断当前连接是否是历史连接：

**原因二：同步双方初始序列号**

**序列号**是可靠传输的一个关键因素，他的作用如下：

* 接收方可以去除重复数据
* 接送方可以根据数据包的序列号，按序接受
* 可以标识发送出去的数据包，判断哪些数据包是已经被对方接收到的。

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912131332.png)

> 四次握手也可以同步初始序列号，但是**第二步与第三步可以优化成一步**
>
> 两次握手只能保证一方那个的初始序列号被对方成功接受，不能保证双方的初始序列号都能确认接受

**原因三：避免资源浪费**

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912131827.png)

> 如果是两次握手连接，在网络情况复杂的情况下，客户端的`SYN` 阻塞了，重复发送多次`SYN`报文，那么服务器在收到请求后就会**建立多个冗余无效的连接，造成不必要的资源浪费**



小结：

TCP建立连接，通过**三次握手**的原因：

> 能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序 列号。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用**两次握手**的原因：

> 无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

不使用**四次握手**的原因：

> 三次握手是理论上最少次数可靠连接建立，不需要使用更多的通信次数，节约资源。

### 8.刚才你提到前两次握手时随机生成的序列号，为什么要随机生成，为什么客户端和服务端初始序列号是不同的？

如果⼀个已经失效的连接被重新建立起来了，但是该旧连接的历史报⽂可能还残留在⽹络中（**还没有到达接收方**），如果序列号相同，那么就⽆法分辨 出该报⽂是不是历史报⽂，如果历史报⽂被新的连接接收了，则会产⽣**数据错乱。**

 所以，每次建⽴连接前重新初始化⼀个序列号主要是为了**通信双⽅能够根据序号将不属于本连接的报⽂段丢弃。**

另一方面时为了安全性，**防止黑客伪造相同序列号TCP报文被对方接收**。

参考图：

![这里写图片描述](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912143300.png)

### 9.简述TCP的四次挥手的过程

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210913115419.png)

* 客户端打算关闭连接，此时会发送一个`FIN`置为1的TCP报文，即`FIN`报文，之后客户端进入`FIN_WAIT_1`状态
* 服务端收到此报文后，会回复一个`ACK`确认应答报文，之后服务端进入`CLOSED_WAIT`状态
* 客户端收到服务端发过来的`ACK`应答报文，之后进入`FIN_WAITE_2`状态
* 等待服务端处理完数据后，也向客户端发送`FIN`报文之后服务端进入`LAST_ACK`状态
* 客户端收到服务端的`FIN`报文后，向服务端发送`ACK`确认应答报文，之后进入`TIME_WAIT`状态
* 服务端收到客户端发送的`ACK`确认应答报文后，就直接进入`CLOSE`状态，至此服务端已经完成连接关闭
* 客户端经过`2MSL`一段时间后，自动进入`CLOSED`状态，客户端完成连接关闭



### 10.为什么挥手需要四次，不能三次吗？

* 关闭连接时，客户端会发送一个`FIN`报文，仅仅表示**客户端不再发送数据，但是可以接受数据**。
* 服务端接受后，返回一个`ACK`确认应答报文，可能**服务端还有数据需要处理和发送**，等待服务端不再发送数据时候，才发送`FIN`报文，表示同意关闭连接

有上面过程可知，服务端**需要将未处理完的数据，进行处理以及发送**。所以服务端的`FIN`和`ACK`报文分开发送，而不是一起发送.

### 11.为什么TIME_WAITE需要2MSL，不能立即关闭吗？



### TCP如何保证可靠传输

### **TCP 长连接和短连接的区别**

### **TCP粘包、拆包及解决办法**



### 介绍UDP

UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向**「⽆连接」**的通信服务。 

UDP 的头部格式如下：

![image-20210911144021592](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911144021.png)

### 

参考博客：

https://www.jianshu.com/p/9b9438dff7a2

https://snailclimb.gitee.io/javaguide/#/docs/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=_11-%e5%ba%94%e7%94%a8%e5%b1%82

https://blog.csdn.net/qq_35733751/article/details/80552037

https://blog.csdn.net/csdnnews/article/details/105424412

> 修改时间：{docsify-updated}
# 计算机网络面试题汇总

## OSI 与 TCP/IP篇

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911124706.gif)

### 1.OSI模型或者TCP/IP模型各层的功能,都有哪些协议?

 **物理层**

> 实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异（比特流）

**数据链路层**

> 建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现就直接丢弃。(帧)

 **网络层**

> 选择合适的网间路由和交换结点， 确保数据及时传送。协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP（分组或者包）

**传输层**

> 负责向两台主机进程之间的通信提供通用的数据传输服务。协议有：TCP UDP，

**会话层**

> 建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话

 **表现层**

> 数据的表示、安全、压缩。格式有，JPEG、ASCll、DECOIC、加密格式等

 **应用层**

> 通过应用进程间的交互来完成特定网络应用，协议有：HTTP FTP TFTP（文件传输） SMTP（电子邮件传输） SNMP（网络管理） DNS（域名系统） TELNET（远程登录） HTTPS  DHCP（动态主机配置）

**至于tcp/ip模型你选择OSI模型对应的层去说即可**

![五层体系结构](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911134031.png)

七层模型传输数据过程：

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911131915.webp)

### 2.为什么要分层，分层有什么意义？

> 1. 各层之间是独立的。某一层可以使用其下一层提供的服务而不需要知道服务是如何实现的。
>
> 2.  灵活性好。当某一层发生变化时，只要其接口关系不变，则这层以上或以下的各层均不受影响。
>
> 3.  结构上可分割开。各层可以采用最合适的技术来实现 
>
> 4. 易于实现和维护。 
>
> 5. 能促进标准化工作。
>
>    与分层体系结构的思想相似的日常生活有邮政系统，物流系统。

## TCP篇

### 1.什么是TCP

> TCP是**面向连接的，可靠的，基于字节流**的传输层通信协议

面向连接的：

>  ⼀定是**「⼀对⼀」**才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀ 对多是⽆法做到的；

可靠的：

> ⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；

基于字节流：

>  消息是**「没有边界」**的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是**「有序的」**，当 **「前⼀个」**消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对**「重复」**的报⽂会⾃动丢弃。

### 2.TCP的头格式是什么？

​																						**TCP头部格式**

![image-20210911140927364](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911140927.png)

**序列号（seq）**：

> 在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据字节数」的⼤⼩。
>
> **用来解决⽹络包乱序问题**。

**确认应答号（ack）**：

> 指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。
>
> **用来解决不丢包的问题。**

控制位：

> * ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必 须设置为 1 。
>
> * RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
>
> * SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。 
>
> * FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

### 3.为什么需要TCP协议，他工作在哪一层？

> 网络层是**不可靠**的，他不能保证网络包的**按序交付**，也不能保证**网络包中的数据完整性**！所以就有传输层的**TCP协议**负责网络数据包的可靠性！

### 4.tcp是面向连接的，那么怎么确认是唯一的连接？

* 源地址
* 目的地址
  * 通过ip协议发送报文给对方主机
* 源端口
* 目的端口
  * 告诉TCP协议应该把报文发送给哪一个进程

### 5.传输层有TCP与UDP协议，他们之间区别是什么，分别应用的场景是哪儿？

**TCP与UDP区别：**

1. 连接
   * TCP是面向连接的，传输数据首先要**建立连接**，
   * UDP**不需要建立连接**，即刻传输数据
2. 服务对象
   * TCP协议是一对一传输
   * UDP是可以一对一，一对多，多对多的交互通信
3. 可靠性
   * TCP是可靠交付数据的，数据无差错，不丢失，不重复，按需到达
   * UDP尽最大努力交付，不能保证可靠性
4. 首部开销
   * TCP首部长度较长一般是20字节
   * UDP首部只有8个字节，固定不变，开销小
5. 传输方式
   * TCP 是流式传输，没有边界
   * UDP是一个一个包传输的，有边界

**TCP与UDP应用的场景：**

TCP是面向连接的，具有可靠性的，经常用于

* FTP文件传输
* HTTP/HTTPS
* SMTP邮件传输

UDP是不需要连接，尽最大努力交付的，经常用于：

* 视频，音频等多媒体通信
* 游戏网络通信
* 广播通信

### 6.简述TCP三次握手的过程

TCP 通过**三次握手**来建立连接

![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911145410.png)

**三次握手**过程如下：

* 一开始，客户端和服务端都处于`CLOSED`
* 先是服务端主动监听某个端口，处于`LISTEN` ,开始接受第一个报文
* 客户端随机初始化序列号（**client_isn**），同时控制位中的`SYN`置为1。第一个报文发送到服务端，表示向服务端发起连接请求，之后客户端处于`SYN-SENT`状态
* 服务端收到报文后，服务端随机初始化序列号（**server_isn**）,确认应答号（**ack**）填入`client_isn+1` 接着`SYN`和`ACK` 都置为1，发送报文到客户端，该报文不包含应用层数据，之后服务端处于`SYN-RCVD`状态
* 客户端收到报文后，还要向服务端回应一个应答报文，`ACK`置为1 ，确认应答号（**ack**）填入`server_isn+1` ，序列号可以填入应用层的数据，之后客户端处于`ESTABLISHEN`状态
* 服务器收到客户端的应答报文后，也进入`ESTABLISHED`状态

**温馨提示**：

> 第三次握手是可以携带数据的，前面两次的序列号都随机生成，不可以携带数据

**那么为什么前两次不能携带数据？**

> 减少服务器被攻击的风险。如果前两次能够携带数据，一旦有人想要攻击服务器，就可以在第一次握手中的SYN的报文放入大量数据，服务器势必会消耗更多的时间和内存空间去处理这些数据，就增加了服务器被攻击的风险。
>
> 第三次握手，客户端已经处于`ESTABLISHED`状态，可以接受服务器的报文，相对安全

参考博客：

https://blog.csdn.net/King___Ding/article/details/114873086

### 7.为什么是三次握手，不是两次，或者四次呢？

比较常回答的是“因为三次握⼿才能保证双⽅具有接收和发送的能⼒。”

但是这回答比较片面，，没有说到点子上，面试官不愿听

接下来以三个方面分析三次握手的原因：

* **三次握手才可以阻止重复历史连接的初始化**（主要原因）
* **三次握手才可以同步双方的初始序列号**
* **三次握手才可以避免资源浪费**

**原因一：避免历史连接**

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912120023.png)



三次握手的**首要原因是为防止旧的重复连接引起连接初始化混乱的问题。**

三次握手避免历史连接过程如下：

* 一个**旧的SYN报文**会比**新的SYN报文**先到服务端
* 服务端返回一个`SYN+ACK`报文到客户端
* 客户端通过自身的上下文,判断此连接是否是一个历史连接？
  * 如果是，客户端返回一个`RET`报文，终止此次连接，等待正确的SYN+ACK报文
  * 如果不是，则建立连接

> 如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送⽅）准备发送第三次 报⽂时，客户端因有足够的上下文来判断当前连接是否是历史连接：

**原因二：同步双方初始序列号**

**序列号**是可靠传输的一个关键因素，他的作用如下：

* 接收方可以去除重复数据
* 接送方可以根据数据包的序列号，按序接受
* 可以标识发送出去的数据包，判断哪些数据包是已经被对方接收到的。

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912131332.png)

> 四次握手也可以同步初始序列号，但是**第二步与第三步可以优化成一步**
>
> 两次握手只能保证一方那个的初始序列号被对方成功接受，不能保证双方的初始序列号都能确认接受

**原因三：避免资源浪费**

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912131827.png)

> 如果是两次握手连接，在网络情况复杂的情况下，客户端的`SYN` 阻塞了，重复发送多次`SYN`报文，那么服务器在收到请求后就会**建立多个冗余无效的连接，造成不必要的资源浪费**



小结：

TCP建立连接，通过**三次握手**的原因：

> 能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序 列号。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用**两次握手**的原因：

> 无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

不使用**四次握手**的原因：

> 三次握手是理论上最少次数可靠连接建立，不需要使用更多的通信次数，节约资源。

### 8.刚才你提到前两次握手时随机生成的序列号，为什么要随机生成，为什么客户端和服务端初始序列号是不同的？

如果⼀个已经失效的连接被重新建立起来了，但是该旧连接的历史报⽂可能还残留在⽹络中（**还没有到达接收方**），如果序列号相同，那么就无法分辨 出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生**数据错乱。**

 所以，每次建立连接前重新初始化⼀个序列号主要是为了**通信双方能够根据序号将不属于本连接的报文段丢弃。**

另一方面时为了安全性，**防止黑客伪造相同序列号TCP报文被对方接收**。

参考图：

![这里写图片描述](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210912143300.png)

### 9.简述TCP的四次挥手的过程

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210913115419.png)

* 客户端打算关闭连接，此时会发送一个`FIN`置为1的TCP报文，即`FIN`报文，之后客户端进入`FIN_WAIT_1`状态
* 服务端收到此报文后，会回复一个`ACK`确认应答报文，之后服务端进入`CLOSED_WAIT`状态
* 客户端收到服务端发过来的`ACK`应答报文，之后进入`FIN_WAITE_2`状态
* 等待服务端处理完数据后，也向客户端发送`FIN`报文之后服务端进入`LAST_ACK`状态
* 客户端收到服务端的`FIN`报文后，向服务端发送`ACK`确认应答报文，之后进入`TIME_WAIT`状态
* 服务端收到客户端发送的`ACK`确认应答报文后，就直接进入`CLOSE`状态，至此服务端已经完成连接关闭
* 客户端经过`2MSL`一段时间后，自动进入`CLOSED`状态，客户端完成连接关闭



### 10.为什么挥手需要四次，不能三次吗？

* 关闭连接时，客户端会发送一个`FIN`报文，仅仅表示**客户端不再发送数据，但是可以接受数据**。
* 服务端接受后，返回一个`ACK`确认应答报文，可能**服务端还有数据需要处理和发送**，等待服务端不再发送数据时候，才发送`FIN`报文，表示同意关闭连接

有上面过程可知，服务端**需要将未处理完的数据，进行处理以及发送**。所以服务端的`FIN`和`ACK`报文分开发送，而不是一起发送.

### 11.为什么需要TIME_WAIT状态

根据第三版《UNIX网络编程 卷1》2.7节，TIME_WAIT状态的主要目的有两个：

- **优雅的关闭TCP连接**，也就是尽量保证被动关闭的一端收到它自己发出去的FIN报文的ACK确认报文；

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210915193018.png)

- **处理延迟的重复报文**，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接。

![img](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210915193006.png)

### 12.为什么TIME_WAITE需要2MSL，不是更多呢?

`MSL` 是**报文最大生存时间**，如果超过这个时间，报文就会被丢弃。是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

> `MSL`与`TTL`的区别：
>
> * `MSL` 的单位是时间
> * `TTL`是经过路由跳数
>
> 所以`MSL`应该要大于等于`TTL`消耗为0的时间，以确保报文已被自然消亡

当客户端发送最后一个ACK报文，服务端处于LAST_ACK状态，在收到最后一个ACK之前它会一直重传FIN报文直至超时。那么客户端发送到服务端的ACK报文有两种结局

* ACK在网络中丢失，我觉得情况不需要考虑，因为tcp是可靠连接，因为除非多次重传失败，否则AB两端的状态不会发生变化直至最后一个ACK不再丢失。
* ACK报文被B接收到。我们假设A发送了ACK报文后过了一段时间t之后B才收到该ACK，则有 0 < t <= MSL。因为A并不知道它发送出去的ACK要多久对方才能收到，所以A至少要维持MSL时长的TIME_WAIT状态才能保证它的ACK从网络中消失。同时处于LAST_ACK状态的B因为收到了ACK，所以它直接就进入了CLOSED状态，而不会向网络发送任何报文。所以晃眼一看，A只需要等待1个MSL就够了，但仔细想一下其实1个MSL是不行的，因为在B收到ACK前的一刹那，B可能因为没收到ACK而重传了一个FIN报文，这个FIN报文要从网络中消失最多还需要一个MSL时长，所以A还需要多等一个MSL。

综上所诉`TIME_WAIT`等待2倍的`MSL`比较合理解释：

> 第一个MSL是为了等自己发出去的最后一个ACK报文从网络消失，第二个MSL是对了等服务端收到ACK之前的一刹那可能重传的FIN报文从网络消失

**虽然说维持TIME_WAIT状态一段时间有2个目的，但这段时间具体应该多长主要是为了达成上述第二个目的而设计的。**



**为什么不是 4 或者 8 MSL 的时长呢？**

> 你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。

### 13.TCP如何保证可靠传输

>  是通过序列号、确认应答、重发控制、连接管理以及窗⼝控制等机制实现可靠性传输的。

### 14.简单讲讲TCP常见的重传机制

**TCP 实现可靠传输的方式之一，是通过序列号与确认应答。**

#### 超时重传

> 重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

发生超时重传的情况如下：

* 数据包丢失
* 确认应答ACK丢失

> 超时时间设置为多少

![RTT](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210915210442.jpeg)

`RTT` 就是**数据从网络一端传送到另一端所需的时间**，也就是包的往返时间。

超时重传时间是以 `RTO` （Retransmission Timeout 超时重传时间）表示。

![超时时间较长与较短](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210915210655.jpeg)

- 当超时时间 **RTO 较大**时，重发就慢，丢了老半天才重发，没有效率，性能差；
- 当超时时间 **RTO 较小**时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

根据上述的两种情况，我们可以得知，**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**。

实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个**动态变化的值**。

### 介绍UDP

UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向**「⽆连接」**的通信服务。 

UDP 的头部格式如下：

![image-20210911144021592](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210911144021.png)

### 

参考博客：

https://snailclimb.gitee.io/javaguide/#/docs/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C?id=_11-%e5%ba%94%e7%94%a8%e5%b1%82

七层模型：

https://www.jianshu.com/p/9b9438dff7a2

TCP连接三次握手四次挥手

https://blog.csdn.net/csdnnews/article/details/105424412

TCP连接–初始化序列号

https://blog.csdn.net/qq_35733751/article/details/80552037

TCP连接四次挥手

https://cloud.tencent.com/developer/article/1450264

TCP重传机制、滑动窗口、流量控制、拥塞控制。

https://www.cnblogs.com/xiaolincoding/p/12732052.html

> 修改时间：{docsify-updated}
# 1.网页输入一个 url, 会发生什么

推荐博客：[https://www.cnblogs.com/mengxiangji/p/11297718.html](https://www.cnblogs.com/mengxiangji/p/11297718.html)

> 流程：
>
> 1. DNS解析
> 2. TCP连接
>    1. tcp三次握手
> 3. 发送http请求
> 4. 服务器处理请求
> 5. 浏览器解析渲染页面
>    1. 解析HTML生成DOM树
>    1. 解析CSS生成CSSOM规则树
>    1. 将DOM树与CSSOM规则树合并在一起生成渲染树
>    1. 遍历渲染树开始布局，计算每个节点的位置大小信息
>    1. 将渲染树每个节点绘制到屏幕
> 6. 连接结束
>    1. tcp四次挥手

# 2.TCP三次握手、四次挥手，timewait，closewait状态

推荐博客：[https://blog.csdn.net/qq_38950316/article/details/81087809](https://blog.csdn.net/qq_38950316/article/details/81087809)
tcp:
![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180301.png)
		序列号seq：

> 占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

确认号ack：

> 占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

确认ACK：

> 占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

同步SYN：

> 连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。

终止FIN：

> 用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

三次握手：
![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180308.png)

> 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
> ​

> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
> ​

> 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

四次挥手：
![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180311.png)

> 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
> 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
> 3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
> 4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
> 5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
> 6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

相关问题：
【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？

> 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

> 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

【问题3】为什么不能用两次握手进行连接？
​

> 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

> 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？
​

> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

# 3.get、post方法有什么区别

推荐博客：[https://www.cnblogs.com/logsharing/p/8448446.html](https://www.cnblogs.com/logsharing/p/8448446.html)
GET和POST是什么？

> HTTP协议中的两种发送请求的方法。

HTTP是什么？

> HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。

> HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 



> 之所以会有区别是因为（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。

> GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

# 4.流量控制，拥塞控制。

推荐博客：

[https://blog.csdn.net/dangzhangjing97/article/details/81008836](https://blog.csdn.net/dangzhangjing97/article/details/81008836)

[https://www.cnblogs.com/sunweiye/p/11106932.html](https://www.cnblogs.com/sunweiye/p/11106932.html)

## 流量控制：

1. 什么是流量控制

> Sender won’t overflow receiver’s buffer by transmitting too much, too fast. （防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理）

2. 什么方式实现流量控制

> 利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。
> TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。

![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180316.png)
分析：

1. 接收方的主机A进行了三次流量控制，第一次把窗口减小到rwnd  =300。
1. 第二次又减小到rwnd = 100。
1. 最后减到rwnd = 0，即不允许发送方再发生数据了。
1. 这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。
1. B向A发送的三个报文段都设置了ACK = 1,只有在ACK = 1时确认号字段才有意义。(相当于判定条件，只有条件成立时，才去查下面的信息)

可能出现的问题：
**死锁问题**
发送端A与接受端B，当前B发出rwnd=400的报文段，但是报文段丢失，A在等待B发送窗口此时不为0的报文，而B在等待A的发送数据。就会出现死锁的现象。
解决方法：

1. TCP为每一个连接设有一个持续计时器。
1. 只要TCP连接的一方收A到对方的零窗口通知，就启动持续计时器。
1. 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方B就在确认这个探测报文时给出了现在的窗口值。
1. 如果窗口值仍然是零，那么收到这个报文段的一方就重新设置持续计时器。
1. 如果窗口不是零，那么死锁的僵局就可以打破了。

## 拥塞控制

1. 什么是拥塞控制

> too many sources sending too much data too fast for network to handle
> 防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞

2. 怎样实现拥塞控制

> 1.慢开始
> 2.拥塞避免
> 3.快重传
> 4.快恢复

慢开始

> 1.当主机开始发送数据时，由于并不清楚网络的负荷情况，所以如果立即把大量数据字节注入到网络，那么就有可能引起网络发生拥塞。
> 2.经验证表明，较好的办法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口的数值。

拥塞避免

> 让拥塞避免窗口cwnd缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

什么是ssthresh状态变量，以及作用

> 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量
>
> 1. 当cwnd < ssthresh时，使用上述的慢开始算法
> 1. 当cwnd > ssthresh时，  停止使用慢开始算法而改用拥塞避免算法
> 1. 当cwnd = ssthresh时 ， 即可以使用慢开始算法，也可以使用拥塞避免算法。

快重传
![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180327.png)

> 当接收端发送了三个重复的确认报文，则发送端立即重传下一个
> 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。

快恢复

> 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始与快恢复的区别

> 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。
> 慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180332.png)
![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180437.png)

# 5.http 和 https 的区别

推荐博客：

[https://blog.csdn.net/qq_38289815/article/details/80969419](https://blog.csdn.net/qq_38289815/article/details/80969419)

[https://tyler-zx.blog.csdn.net/article/details/107591115](https://tyler-zx.blog.csdn.net/article/details/107591115)

[https://www.runoob.com/w3cnote/http-vs-https.html](https://www.runoob.com/w3cnote/http-vs-https.html)

1. 什么是http和https？

http

> 是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。

https

> 是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

2. 为什么会出现https

> HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。
> 为了提供对网站服务器的身份认证，保护交换数据的隐私与完整性。就产生出HTTPS。

3. https工作流程

> 1. TCP 三次同步握手
> 1. 客户端验证服务器数字证书
> 1. DH 算法协商对称加密算法的密钥、hash 算法的密钥
> 1. SSL 安全加密隧道协商完成
> 1. 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

4. 两者区别

> - 加密性：HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
> - 是否使用证书： 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
> - 响应速度：HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
> - 连接方式：http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
> - 协议：HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

5. HTTPS工作原理

![image.png](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210905180338.png)
1、**客户端发起 HTTPS 请求**
这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。
2、**服务端的配置**
采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。
这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
3、**传送证书**
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
4、**客户端解析证书**
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
5、**传送加密信息**
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6、**服务端解密信息**
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7、**传输加密后的信息**
这部分信息是服务段用key加密后的信息，可以在客户端被还原。
8、**客户端解密信息**
客户端用之前生成的key解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

# 6.https 最耗时的环节

ssl协议握手

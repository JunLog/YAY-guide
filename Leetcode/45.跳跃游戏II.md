# 45.跳跃游戏II

[力扣题目链接](https://leetcode-cn.com/problems/jump-game-ii/)

## 思路

这道题目和55.跳跃游戏就有点不同了，他已经保证了他能到达最后下标处，你现在要做的就是**使跳的次数最小**

我们来贪心一波，次数最小，那么需要的是**我跳的距离保证加一定是最远的**

你可能有疑惑了，这怎么保证啊！

举例：

`nums=[2,3,1,1,4]`

我处于nums[0]，我能跳的范围是nums[1].nums[2].我要我下一次能跳的很远很远，当我跳到了nums[1],我下次就可以直接到最后下标了。当我跳到了nums[2],我能跳最大跳跃长度很小，最多到达nums[3].所以我就选择nums[1]处跳跃了，他的最大跳跃长度比nums[1]大。

至于什么时候计数，当然是我把我能跳的范围试一遍，然后**从他们最大的跳跃长度中选择最远的距离**，能保证我下一跳，跳的最大跳跃长度每次都是最远的，就可以计数了。

核心思想是：

> 在我**当前能跳的范围**了里面，从范围里面每一个位置的**最大的跳跃长度**中选择**最远的距离**！！

感觉有点拗口😋😋😋，多思考一下加粗的部分。

## 代码

```Go
func jump(nums []int) int {
    ans:=0
    cur:=0
    next:=0
    for i:=0;i<len(nums)-1;i++{//因为题目已经保证我能到最后的下标了
        next=max(i+nums[i],next)//每一个位置的最大跳跃长度中选择最大的距离
        if i==cur{//到达我之前跳的范围了，选择最大的跳，计数
            ans++
            cur=next
        }
    }
    return ans
}
func max(a,b int) int{
    if a>b{
        return a
    }
    return b
}
```




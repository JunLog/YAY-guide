# 96.不同的二叉搜索树

[力扣题目链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)

## 思路

先看三个图吧！（来自代码随想录）

![96.不同的二叉搜索树](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210929150616.png)

![图片](https://img-blog.csdnimg.cn/20210107093129889.png)

看上面举例的三个图，不知道你有没有发现规律。

以n=3举例。

当根节点为1时候，他的子树布局与n=2的时候树的布局一致。

当根节点为2时候，他的子树布局与n=1布局一致

当根节点为3时候，他的子树布局与n=2时候树的布局一致。

（此题他只与树的个数有关，与节点布局无关，不用关心具体数值的摆放）

那么，dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

看到这里是不是已经知道了递推公式了。

动规五部曲

* dp数组以及下标的定义

> dp[i] 表示当n=2时候，所能得到的二叉搜索树的个数

* dp的递推公式

> 如果你能看明白之前的分析，那么下面递推公式，你可以能懂
>
> 递推公式：dp[i]+=dp[i-j]*dp[j]

* dp遍历顺序

> 因为需要用到之前的树的值所以
>
> * i从1到n遍历，求n=i的二叉搜索树的个数
> * j从0到i-1遍历，获取不同子树的二叉搜索树的个数然后加起来。

* dp初始化

> dp[0]=1
>
> dp[1]=1

* 打印dp

> ![96.不同的二叉搜索树3](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210929152038.png)

## 代码

```go
func numTrees(n int) int {
    dp:=make([]int,n+1)
    dp[0]=1
    dp[1]=1
    //ans:=0
    for i:=2;i<=n;i++{
        for j:=0;j<=i-1;j++{
               
            dp[i]+=dp[i-j-1]*dp[j]
           
        }
        
    }
    
    return dp[n]
}
```


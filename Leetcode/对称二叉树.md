#  101. å¯¹ç§°äºŒå‰æ ‘

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/symmetric-tree/)

æ¨èé˜…è¯»ï¼š[ä»£ç éšæƒ³å½•](https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95)

![image-20210910131206072](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210910131213.png)

è¿™é“é¢˜ç›®ç»™æˆ‘çš„ç¬¬ä¸€ååº”å°±æ˜¯**å±‚åºéå†**å»è§£å†³ã€‚å› ä¸ºä»–æ˜¯å¯¹**æ¯ä¸€å±‚è¿›è¡Œå¤„ç†çš„**ã€‚

## å±‚åºéå†

æ€è·¯ï¼š

* ä»¥å±‚åºéå†äºŒå‰æ ‘
* å½“éå†åˆ°nilæ—¶å€™å°±æ˜¯æ ‡è®°æˆä¸€ä¸ªç‰¹æ®Šçš„æ•°å­—ï¼ˆ**è¿™ä¸ªéšæ„ï¼Œåªè¦æ ·ä¾‹æ²¡æœ‰**ï¼‰
* ç„¶åæ¯ä¸€å±‚è¿›è¡Œé¦–å°¾åŒ¹é…

```go
func isSymmetric(root *TreeNode) bool {
    queue:=list.New()
    queue.PushBack(root)
   res:=[][]int{}
    for queue.Len()>0{
         ans:=[]int{}
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            if node==nil{
                ans=append(ans,-10)
                continue
            }
            ans=append(ans,node.Val)
            queue.PushBack(node.Left)
            queue.PushBack(node.Right)
        }
        res=append(res,ans)
    }
    for i:=0;i<len(res)-1;i++{
        for j:=0;j<len(res[i])/2;j++{
            if res[i][j]!=res[i][len(res[i])-1-j]{
                return false
            }
        }
    }
    return true
}
```

ä½†æ˜¯è¿™ä¸ªæ–¹æ³•æœ‰é—®é¢˜ï¼ï¼ï¼ï¼

å½“èŠ‚ç‚¹ä¸ºnilæ—¶å€™å¯¹åº”çš„æ•°å­—æ˜¯å¤šå°‘ã€‚**å› ä¸ºè¿™æ˜¯è¿‡é¢˜æ‰€ä»¥ä½ å¤šè¯•è¯•å°±ä¼šçŸ¥é“æ ·ä¾‹æ²¡æœ‰å‡ºç°çš„æ•°å­—**ã€‚



## é€’å½’

![image-20210910133225114](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210910133225.png)

æ€è·¯ï¼š

* å°†èŠ‚ç‚¹åˆ†æˆå·¦å³å­æ ‘ï¼Œç„¶åå­æ ‘åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå¤–ä¾§è¿›è¡Œæ¯”æ¯”è¾ƒï¼Œå†…ä¾§è¿›è¡Œæ¯”è¾ƒ
* å¯ä»¥è€ƒè™‘é€’å½’å»å®Œæˆéå†
* æ³¨æ„èŠ‚ç‚¹æ˜¯å¦ä¸ºnilã€‚

```go
func isSymmetric(root *TreeNode) bool {
    if root==nil{
        return true
    }
    return compare(root.Left,root.Right)
}
func compare(left,right *TreeNode) bool{
    //ç»ˆæ­¢æ¡ä»¶
    if left==nil&& right==nil{
        return true
    }else if right!=nil&&left==nil{
        return false
    }else if left!=nil&& right==nil{
        return false
    }else if left.Val!=right.Val{
        return false
    }

    return compare(left.Left,right.Right)&&compare(left.Right,right.Left)
}
```

## è¿­ä»£

![101.å¯¹ç§°äºŒå‰æ ‘](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210910141228.gif)

ä»£ç éšæƒ³å½•è¿™ä¸ªå›¾å°±å¾ˆå¥½çš„è§£é‡Šäº†è¿­ä»£æ³•çš„æ€è·¯

è¿™æ˜¯åˆ©ç”¨çš„é˜Ÿåˆ—

```go
func isSymmetric(root *TreeNode) bool {
    queue:=list.New()
    queue.PushBack(root.Left)
    queue.PushBack(root.Right)
    for queue.Len()>0{
        tree1:=queue.Remove(queue.Front()).(*TreeNode)
        tree2:=queue.Remove(queue.Front()).(*TreeNode)
        if tree1==nil&&tree2==nil{
            continue
        }
        if !(tree1!=nil&&tree2!=nil)||(tree1.Val!=tree2.Val){
            return false
        }
        queue.PushBack(tree1.Left)
        queue.PushBack(tree2.Right)
        queue.PushBack(tree1.Right)
        queue.PushBack(tree2.Left)
    }
    return true
}
```

**å…¶å®ç”¨æ ˆä¹Ÿå¯ä»¥ï¼Œå…¶å®å•¥ä¹Ÿæ²¡æœ‰æ”¹å˜ï¼Œä½ éœ€è¦æŠŠæ ˆæ¢æˆé˜Ÿåˆ—å°±å¥½äº†**

## ç±»ä¼¼é¢˜ç›®

### [100. ç›¸åŒçš„æ ‘](https://leetcode-cn.com/problems/same-tree)

### [572. å¦ä¸€æ£µæ ‘çš„å­æ ‘](https://leetcode-cn.com/problems/subtree-of-another-tree/)

å¦‚æœä¸Šé¢ä¸€é¢˜çš„é€’å½’å’Œè¿™ä¸¤ä¸ªé¢˜ç›®çš„é€’å½’å¾ˆç±»ä¼¼ã€‚ã€‚

äºŒå‰æ ‘ä½ è¦æ‹†è§£æˆä¸‰éƒ¨åˆ†

* æ ¹èŠ‚ç‚¹
* å·¦å­æ ‘
* å³å­æ ‘

ç¬¬ä¸€æ­¥ï¼š

>  æ¯”è¾ƒæ ¹èŠ‚ç‚¹ï¼ˆåˆ¤ç©ºï¼Œåˆ¤å€¼ï¼‰

ç¬¬äºŒæ­¥ï¼š

>  è·‘åˆ°å·¦å­æ ‘ï¼Œæ¯”è¾ƒç›¸å¯¹åº”çš„å­æ ‘

ç¬¬ä¸‰æ­¥ï¼š

>  è·‘åˆ°å³å­æ ‘ï¼Œæ¯”è¾ƒç›¸å¯¹åº”çš„å­æ ‘

åŸºæœ¬ä¸Šä¸‰é“é¢˜ç›®éƒ½æ˜¯è¿™ä¸ªå¤§æ¦‚æ€è·¯

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p==nil&&q==nil{//åˆ¤ç©º
        return true
    }else if p==nil||q==nil{//åˆ¤ç©º
        return false
    }else if p.Val==q.Val{//åˆ¤å€¼
        return isSameTree(p.Left,q.Left)&&isSameTree(p.Right,q.Right)//å·¦å­æ ‘ä¸å³å­æ ‘è¿›è¡Œç›¸å¯¹åº”çš„æ¯”è¾ƒ
    }else {
        return false
    }
    
}
```



```go
func isSubtree(root *TreeNode, subRoot *TreeNode) bool {
    if root==nil{
        return false
    }
    //å…ˆæ¯”è¾ƒæ ¹èŠ‚ç‚¹ï¼Œç„¶åè·‘åˆ°å·¦å­æ ‘ï¼Œç„¶åå³å­æ ‘
    return check(root,subRoot) ||isSubtree(root.Left,subRoot)||isSubtree(root.Right,subRoot)
}

func check(root *TreeNode,subRoot *TreeNode) bool{
    if root==nil&&subRoot==nil{//åˆ¤ç©º
        return true
    }else if root==nil||subRoot==nil{//åˆ¤ç©º
        return false
    }else if root.Val==subRoot.Val{//åˆ¤å€¼
        return check(root.Left,subRoot.Left)&&check(root.Right,subRoot.Right)//å·¦å­æ ‘ä¸å³å­æ ‘è¿›è¡Œç›¸å¯¹åº”çš„æ¯”è¾ƒ
    }
    return false
}
```



æ„Ÿè§‰ä»Šå¤©å†™é€’å½’ï¼Œè„‘å­æœ‰ç‚¹ç³Šï¼ï¼ï¼ï¼éš¾å—ï¼ï¼ğŸ˜¥ğŸ˜¥ğŸ˜¥

#  101. 对称二叉树

[力扣题目链接](https://leetcode-cn.com/problems/symmetric-tree/)

推荐阅读：[代码随想录](https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E9%80%92%E5%BD%92%E6%B3%95)

![image-20210910131206072](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210910131213.png)

这道题目给我的第一反应就是**层序遍历**去解决。因为他是对**每一层进行处理的**。

## 层序遍历

思路：

* 以层序遍历二叉树
* 当遍历到nil时候就是标记成一个特殊的数字（**这个随意，只要样例没有**）
* 然后每一层进行首尾匹配

```go
func isSymmetric(root *TreeNode) bool {
    queue:=list.New()
    queue.PushBack(root)
   res:=[][]int{}
    for queue.Len()>0{
         ans:=[]int{}
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            if node==nil{
                ans=append(ans,-10)
                continue
            }
            ans=append(ans,node.Val)
            queue.PushBack(node.Left)
            queue.PushBack(node.Right)
        }
        res=append(res,ans)
    }
    for i:=0;i<len(res)-1;i++{
        for j:=0;j<len(res[i])/2;j++{
            if res[i][j]!=res[i][len(res[i])-1-j]{
                return false
            }
        }
    }
    return true
}
```

但是这个方法有问题！！！！

当节点为nil时候对应的数字是多少。**因为这是过题所以你多试试就会知道样例没有出现的数字**。



## 递归

![image-20210910133225114](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210910133225.png)

思路：

* 将节点分成左右子树，然后子树分成两部分，外侧进行比比较，内侧进行比较
* 可以考虑递归去完成遍历
* 注意节点是否为nil。

```go
func isSymmetric(root *TreeNode) bool {
    if root==nil{
        return true
    }
    return compare(root.Left,root.Right)
}
func compare(left,right *TreeNode) bool{
    //终止条件
    if left==nil&& right==nil{
        return true
    }else if right!=nil&&left==nil{
        return false
    }else if left!=nil&& right==nil{
        return false
    }else if left.Val!=right.Val{
        return false
    }

    return compare(left.Left,right.Right)&&compare(left.Right,right.Left)
}
```

## 迭代

![101.对称二叉树](https://cdn.jsdelivr.net/gh/baici1/image-host/newimg/20210910141228.gif)

代码随想录这个图就很好的解释了迭代法的思路

这是利用的队列

```go
func isSymmetric(root *TreeNode) bool {
    queue:=list.New()
    queue.PushBack(root.Left)
    queue.PushBack(root.Right)
    for queue.Len()>0{
        tree1:=queue.Remove(queue.Front()).(*TreeNode)
        tree2:=queue.Remove(queue.Front()).(*TreeNode)
        if tree1==nil&&tree2==nil{
            continue
        }
        if !(tree1!=nil&&tree2!=nil)||(tree1.Val!=tree2.Val){
            return false
        }
        queue.PushBack(tree1.Left)
        queue.PushBack(tree2.Right)
        queue.PushBack(tree1.Right)
        queue.PushBack(tree2.Left)
    }
    return true
}
```

**其实用栈也可以，其实啥也没有改变，你需要把栈换成队列就好了**


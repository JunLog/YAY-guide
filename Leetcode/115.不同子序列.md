# 115.不同的子序列

[力扣题目链接](https://leetcode-cn.com/problems/distinct-subsequences/)

本题整体大意就是在S字符串中找到多个T字符串。感觉动态规划只要思路到位就可以了。

## 思路

动规五部曲

> 1.确定dp数组以及下标定义

dp[i] [j]代表以在索引i-1结尾得字符串中有多个索引j-1结尾字符串得方案dp[i] [j]

> 2.确定dp递推公式

当s[i-1]==t[j-1]

可以与s[i-1]进行匹配同时也可以s[i-2]（与之前得字符串）进行匹配。

为什么可以与s[i-2]进行匹配？

因为当前可以匹配，肯定要看之前得是否能匹配上。

当s[i-1]!=t[j-1]

就与之前得字符串s[i-2]进行匹配

其实总体就是与当前能不能匹配成功，如果能就加上，如果不能就不加。整体都要与之前得字符串进行匹配。因为你不知道此时得字符能否与之前的字符串进行匹配。

> 3.初始化

dp[i] [0]代表t字符串是空字符串所以从s字符串变成t字符串只有一种方式那就是删除

dp[i] [0]=1

> 4.dp数组遍历顺序

遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。

> 5.推导dp数组

![115.不同的子序列](https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg)

## 代码

```go
func numDistinct(s string, t string) int {
    n:=len(s)
    m:=len(t)
    dp:=make([][]int,n+1)
    for i:=0;i<=n;i++{
        dp[i]=make([]int,m+1)
    }
    //初始化
    for i:=0;i<=n;i++{
        dp[i][0]=1
    }

    for i:=1;i<=n;i++{
        for j:=1;j<=m;j++{
            //能够匹配成功
            if s[i-1]==t[j-1]{
                dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
            }else {
                //匹配不成功
                dp[i][j]=dp[i-1][j]
            }
        }
    }
    return dp[n][m]
}
```


# 53. 最大子序和

[力扣题目链接](https://leetcode-cn.com/problems/maximum-subarray/)

## 思路

你看到这个题目，你的第一反应是不是暴力解法

- 遍历每一个数组元素，作为起始位置
- 以起始位置开始，遍历每一个元素，记录最大的和

> 时间复杂度:O(N^2)

我们来贪心一波！！！

当我们在遍历每一个元素时候，我们需要贪心的要求到**我只要走过的地方，就是最大的子序和。**

- 当我们遍历每一个元素时候，需要保证**以他为结束的连续和与以他为开始的连续和**找出最大。

感觉有点拗口！！！，我也不太会表述这个意思。

举例：

`[-2,1,-3,4,-1,2,1,-5,4]`

当我们遍历到 4 这个元素时候，我们贪心的想以 3 结尾的一段子序和加上我这个 4 是不是最大的子序和啊，那么就需要与一个参照物进行比较，如果这一段是最大的肯定希望是正数，负数不存在的，就与自身进行比较。

- 如果是最大（正数），那么加我这个 4 肯定比我大
- 如果不是（负数），那么加上我 4 肯定没有大，我就不跟你玩了，我要找其他的。

其实这里的贪心就是我前一个数字他所代表的子序和是不是正数，会不会加上我就会更大。然后就是找最大的子序和了。

```go
func maxSubArray(nums []int) int {
    sum:=0
    maxsum:=nums[0]
    for _,val:=range nums{
        sum=max(val,sum+val)//判断他所代表的子序和是不是正数
        maxsum=max(maxsum,sum)//寻找最大的子序和
    }
    return maxsum
}
func max(a,b int) int{
    if a>b{
        return a
    }else {
        return b
    }
}
```

> 感觉自己讲清楚了，有感觉自己没有讲清楚！！！难搞哦这题！！

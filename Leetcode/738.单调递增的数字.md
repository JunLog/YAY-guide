# 738.单调递增的数字

[力扣题目链接](https://leetcode-cn.com/problems/monotone-increasing-digits/)

题意比较简单，暴力法肯定会导致超时！因为他的数据范围比较大，需要考虑到O（N）的算法。

举例：

98，9>8的，首先让9-1=8，然后8改成9，这样整数就是89，即小于98最大的单调递增函数

解析出来步骤就是

* 如果发现当前的数字大于前一个数字，
* 让当前数字-1
* 然后前一个数字变成9

但是为了使数字更大，应该让可以为9的尽量都是9

那么从哪一个方向遍历呢

如果从前往后遍历。

举例 332.

重复上面的步骤，最后得出的应该使329.

为什么会这样？因为33这两个数字，为了让他更大，我们不会去动他，但是会导致结果变得更大了。

从后往前遍历，重复上诉操作，得到的结果正确，299.



为什么为了使数字更大，应该让可以为9的尽量为9？

> 高位已经减去一了，为了让这个递增数字更大，应该让低位都是9，才会趋于更大，

```go
func monotoneIncreasingDigits(n int) int {
    s:= strconv.Itoa(n)
    ss:=[]byte(s)
    for i:=len(ss)-1;i>0;i--{//从低位往高位遍历
        if ss[i-1]>ss[i]{
            ss[i-1]-=1//高位减一
            for j:=i;j<len(ss);j++{//让低位都是9
                ss[j]='9'
            }
        }
    }
    
    res, _ := strconv.Atoi(string(ss))
    return res
}
```


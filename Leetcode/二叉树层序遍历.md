# äºŒå‰æ ‘å±‚åºéå†

æ¨èé˜…è¯»ï¼š[äºŒå‰æ ‘çš„å±‚åºéå†](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)

**å±‚åºéå†**ï¼Œä¸ä¹‹å‰æˆ‘ä»¬å­¦ä¹ åˆ°çš„**å‰ä¸­ååºéå†**éƒ½ä¸åŒã€‚ä»–æ˜¯ä¸€å±‚ä¸€å±‚çš„å–éå†çš„ï¼Œæˆ‘ä»¬å¯ä»¥å€Ÿç”¨ä¸€ç§æ•°æ®ç»“æ„ï¼ˆ**é˜Ÿåˆ—**ï¼‰å»å®ç°ã€‚

åŸºæœ¬æ€è·¯ï¼š

* éå†å½“å‰å±‚èŠ‚ç‚¹ï¼Œè·å–å€¼
* ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹éƒ½å…¥é˜Ÿåˆ—
* ç›´åˆ°å¶å­èŠ‚ç‚¹

```go
func levelOrder(root *TreeNode) [][]int {
    res:=[][]int{}
    if root==nil{//é˜²æ­¢ä¸ºç©º
        return res
    }
    queue:=list.New()
    queue.PushBack(root)
    var tmpArr []int
    for queue.Len()>0 {
        length:=queue.Len()//ä¿å­˜å½“å‰å±‚çš„é•¿åº¦ï¼Œç„¶åå¤„ç†å½“å‰å±‚ï¼ˆååˆ†é‡è¦ï¼Œé˜²æ­¢æ·»åŠ ä¸‹å±‚å…ƒç´ å½±å“åˆ¤æ–­å±‚ä¸­å…ƒç´ çš„ä¸ªæ•°ï¼‰
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)//å‡ºé˜Ÿåˆ—
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
            tmpArr=append(tmpArr,node.Val)//å°†å€¼åŠ å…¥æœ¬å±‚åˆ‡ç‰‡ä¸­
        }
        res=append(res,tmpArr)//æ”¾å…¥ç»“æœé›†
        tmpArr=[]int{}//æ¸…ç©ºå±‚çš„æ•°æ®
    }
    return res
}
```

ä¸€å¤§æ³¢é¢˜ç›®å³å°†æ¥ä¸´ï¼ï¼ï¼ğŸ›«ğŸ›«ğŸ›«

**åé¢çš„é¢˜ç›®éƒ½æ˜¯å¯ä»¥ç”¨å±‚åºéå†è§£å†³çš„ã€‚åŒæ—¶æˆ‘ä¼šç®€å•å†™ä¸‹æ€è·¯ã€‚**ï¼Œé¢˜ç›®çœŸçš„å¾ˆå¤šï¼ï¼ï¼ï¼

## 102.äºŒå‰æ ‘çš„å±‚åºéå†

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

è¿™æ˜¯å±‚åºéå†çš„æ¿å­é¢˜ç›®

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    res:=[][]int{}
    if root==nil{
        return  res
    }
    queue:=list.New()
    queue.PushBack(root)
    
    for queue.Len()>0{
        var tmpArr []int
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
            tmpArr=append(tmpArr,node.Val)

        }
        res=append(res,tmpArr)
        
    }
    return res
}
```

## 107.äºŒå‰æ ‘çš„å±‚æ¬¡éå† II

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

å±‚åºéå†åï¼Œä½ è¿›è¡Œé¦–å°¾äº¤æ¢å°±å¯ä»¥å¾—åˆ°é¢˜ç›®ä¸­è¦æ±‚çš„ç»“æœ

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrderBottom(root *TreeNode) [][]int {
    res:=[][]int{}
    if root==nil{
        return res
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        ans:=[]int{}
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            ans=append(ans,node.Val)
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
        res=append(res,ans)
    } 
    reverse(res)
    return res
}
func reverse(res [][]int){
    for i:=0;i<len(res)/2;i++{
        res[i],res[len(res)-i-1]=res[len(res)-i-1],res[i]
    }
}
```

##  199.äºŒå‰æ ‘çš„å³è§†å›¾

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

å±‚åºéå†äºŒå‰æ ‘ï¼Œå°†æ¯ä¸€å±‚çš„æœ€åä¸€ä¸ªå…ƒç´ å–å‡ºæ¥ï¼Œå°±å¯ä»¥äº†

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    res:=[][]int{}
    ans:=[]int{}
    if root==nil{
        return ans
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        tmp:=[]int{}
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            tmp=append(tmp,node.Val)
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
        res=append(res,tmp)
    }
    for i:=0;i<len(res);i++{
        ans=append(ans,res[i][len(res[i])-1])
    }
    return ans
}
```

##  637.äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

å±‚åºéå†äºŒå‰æ ‘ï¼Œæ¯ä¸€å±‚çš„å…ƒç´ ç›¸åŠ æœ€åé™¤ä»¥å½“å‰å±‚çš„é•¿åº¦å°±å¾—åˆ°äº†å±‚çš„å¹³å‡å€¼

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func averageOfLevels(root *TreeNode) []float64 {
    res:=[][]int{}
    ans:=[]float64{}
    if root==nil{
        return ans
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        tmp:=[]int{}
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            tmp=append(tmp,node.Val)
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
        res=append(res,tmp)
    }
    for i:=0;i<len(res);i++{
        num:=0
        for j:=0;j<len(res[i]);j++{
            num+=res[i][j]
        }
        ans=append(ans,float64(num)/float64(len(res[i])) )
    }
    return ans
}
```

## 429.Nå‰æ ‘çš„å±‚åºéå†

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

ä¹‹å‰æ˜¯å±‚åºéå†çš„æ˜¯äºŒå‰æ ‘ï¼Œç°åœ¨æ”¹æˆNå‰æ ‘ï¼Œéƒ½æ˜¯ä¸€ä¸ªæ„æ€

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Children []*Node
 * }
 */

func levelOrder(root *Node) [][]int {
    res:=[][]int{}
    if root==nil{
        return res
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        ans:=[]int{}
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*Node)
            ans=append(ans,node.Val)
            for j:=0;j<len(node.Children);j++{
                queue.PushBack(node.Children[j])
            }
        }
        res=append(res,ans)
    }
    return  res
}
```

##  515.åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

å±‚åºéå†äºŒå‰æ ‘ï¼Œæ¯ä¸€å±‚çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œå–å‡ºæœ€å¤§å€¼

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func largestValues(root *TreeNode) []int {
    ans:=[]int{}
    if root==nil{
        return ans
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        tmp:=[]int{}
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            tmp=append(tmp,node.Val)
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
        sort.Ints(tmp)
        ans=append(ans,tmp[len(tmp)-1])
    }
    return ans
}
```

## 116.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

å±‚åºéå†äºŒå‰æ ‘ï¼Œéå†æ¯ä¸€å±‚å…ƒç´ ï¼Œå½“å‰å…ƒç´ NextæŒ‡å‘åé¢ä¸€ä¸ªå…ƒç´ 

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Left *Node
 *     Right *Node
 *     Next *Node
 * }
 */

func connect(root *Node) *Node {
    if root==nil{
        return root
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        length:=queue.Len()
        for i:=0;i<length;i++{
            e:=queue.Remove(queue.Front()).(*Node)
            
            if i<length-1{//ä¿è¯åé¢æœ‰å…ƒç´ 
                ee:=queue.Front().Value.(*Node)
                e.Next=ee//å½“å‰å…ƒç´ NextæŒ‡å‘åé¢çš„å…ƒç´ 
            }
            
            if e.Left!=nil{
                queue.PushBack(e.Left)
            }
            if e.Right!=nil{
                queue.PushBack(e.Right)
            }
        }
    }
    return root
}
```

## 117.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆII

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

**ä¸Šä¸€é¢˜çš„ä»£ç å¯ä»¥å†è¿™é¢˜å¤ç”¨**

## 104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

å±‚åºéå†äºŒå‰æ ‘ï¼Œéå†çš„å±‚æ•°å°±æ˜¯æœ€å¤§çš„æ·±åº¦

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    ans:=0
    if root==nil{
        return 0
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
        ans++//è®°å½•å±‚æ•°
    }
    return ans
}
```

## 111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

[åŠ›æ‰£é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

å½“å‰å…ƒç´ å¦‚æœæ²¡æœ‰å·¦å³å­èŠ‚ç‚¹ï¼Œåˆ™ä»£è¡¨æ­¤æ—¶çš„å±‚æ•°å°±æ˜¯æœ€å°æ·±åº¦

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
    ans:=0
    if root==nil{
        return 0
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()>0{
        length:=queue.Len()
        for i:=0;i<length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            if node.Left==nil&&node.Right==nil{
                return ans+1
            }
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
        ans++
        

    }
    return ans+1
}
```

å¥½ç´¯å•Šå•Šå•Šå•Šï¼ï¼ï¼ï¼

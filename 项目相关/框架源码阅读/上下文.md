# ginçš„ä¸Šä¸‹æ–‡

## ä¸ºä»€ä¹ˆè¦è®¾è®¡Contextå‘¢ï¼Ÿ

1. å¯¹WebæœåŠ¡æ¥è¯´ï¼Œæ— éæ˜¯æ ¹æ®è¯·æ±‚`*http.Request`ï¼Œæ„é€ å“åº”`http.ResponseWriter`ã€‚ä½†æ˜¯è¿™ä¸¤ä¸ªå¯¹è±¡æä¾›çš„æ¥å£ç²’åº¦å¤ªç»†ï¼Œæ¯”å¦‚æˆ‘ä»¬è¦æ„é€ ä¸€ä¸ªå®Œæ•´çš„å“åº”ï¼Œéœ€è¦è€ƒè™‘æ¶ˆæ¯å¤´(Header)å’Œæ¶ˆæ¯ä½“(Body)ï¼Œè€Œ Header åŒ…å«äº†çŠ¶æ€ç (StatusCode)ï¼Œæ¶ˆæ¯ç±»å‹(ContentType)ç­‰å‡ ä¹æ¯æ¬¡è¯·æ±‚éƒ½éœ€è¦è®¾ç½®çš„ä¿¡æ¯ã€‚å› æ­¤ï¼Œå¦‚æœä¸è¿›è¡Œæœ‰æ•ˆçš„å°è£…ï¼Œé‚£ä¹ˆæ¡†æ¶çš„ç”¨æˆ·å°†éœ€è¦å†™å¤§é‡é‡å¤ï¼Œç¹æ‚çš„ä»£ç ï¼Œè€Œä¸”å®¹æ˜“å‡ºé”™ã€‚é’ˆå¯¹å¸¸ç”¨åœºæ™¯ï¼Œèƒ½å¤Ÿé«˜æ•ˆåœ°æ„é€ å‡º HTTP å“åº”æ˜¯ä¸€ä¸ªå¥½çš„æ¡†æ¶å¿…é¡»è€ƒè™‘çš„ç‚¹ã€‚

çœ‹çœ‹å°è£…åçš„å‰åå·®è·ï¼š

net/httpåº“ï¼š

```go
obj = map[string]interface{}{
    "name": "geektutu",
    "password": "1234",
}
w.Header().Set("Content-Type", "application/json")
w.WriteHeader(http.StatusOK)
encoder := json.NewEncoder(w)
if err := encoder.Encode(obj); err != nil {
    http.Error(w, err.Error(), 500)
}
```

ä½¿ç”¨ginæ¡†æ¶ï¼š

```go
c.JSON(200, gin.H{
			"message": "pong",
		})
```

2. é’ˆå¯¹ä½¿ç”¨åœºæ™¯ï¼Œå°è£…`*http.Request`å’Œ`http.ResponseWriter`çš„æ–¹æ³•ï¼Œç®€åŒ–ç›¸å…³æ¥å£çš„è°ƒç”¨ï¼Œåªæ˜¯è®¾è®¡ Context çš„åŸå› ä¹‹ä¸€ã€‚å¯¹äºæ¡†æ¶æ¥è¯´ï¼Œè¿˜éœ€è¦æ”¯æ’‘é¢å¤–çš„åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œå°†æ¥è§£æåŠ¨æ€è·¯ç”±`/hello/:name`ï¼Œå‚æ•°`:name`çš„å€¼æ”¾åœ¨å“ªå‘¢ï¼Ÿå†æ¯”å¦‚ï¼Œæ¡†æ¶éœ€è¦æ”¯æŒä¸­é—´ä»¶ï¼Œé‚£ä¸­é—´ä»¶äº§ç”Ÿçš„ä¿¡æ¯æ”¾åœ¨å“ªå‘¢ï¼ŸContext éšç€æ¯ä¸€ä¸ªè¯·æ±‚çš„å‡ºç°è€Œäº§ç”Ÿï¼Œè¯·æ±‚çš„ç»“æŸè€Œé”€æ¯ï¼Œå’Œå½“å‰è¯·æ±‚å¼ºç›¸å…³çš„ä¿¡æ¯éƒ½åº”ç”± Context æ‰¿è½½ã€‚å› æ­¤ï¼Œè®¾è®¡ Context ç»“æ„ï¼Œæ‰©å±•æ€§å’Œå¤æ‚æ€§ç•™åœ¨äº†å†…éƒ¨ï¼Œè€Œå¯¹å¤–ç®€åŒ–äº†æ¥å£ã€‚è·¯ç”±çš„å¤„ç†å‡½æ•°ï¼Œä»¥åŠå°†è¦å®ç°çš„ä¸­é—´ä»¶ï¼Œå‚æ•°éƒ½ç»Ÿä¸€ä½¿ç”¨ Context å®ä¾‹ï¼Œ Context å°±åƒä¸€æ¬¡ä¼šè¯çš„ç™¾å®ç®±ï¼Œå¯ä»¥æ‰¾åˆ°ä»»ä½•ä¸œè¥¿ã€‚

## Context

```go
r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
		})
	})
```

åªè¦ä½ å†™`handlerFunc`,ä¸€èˆ¬ä½ çš„å‚æ•°éƒ½æ˜¯`c *gin.Context`ï¼Œä»Šå¤©æˆ‘ä»¬æ¥æ­å¼€`Context`çš„ç¥ç§˜é¢çº±!ğŸ‘€ğŸ‘€ğŸ‘€

Contextç»“æ„å¦‚ä¸‹ï¼š

```go
// ä¸Šä¸‹æ–‡æ˜¯ gin ä¸­æœ€é‡è¦çš„éƒ¨åˆ†ã€‚ å®ƒå…è®¸æˆ‘ä»¬åœ¨ä¸­é—´ä»¶ä¹‹é—´ä¼ é€’å˜é‡ï¼Œ
// ç®¡ç†æµç¨‹ï¼Œä¾‹å¦‚éªŒè¯è¯·æ±‚çš„ JSON å¹¶å‘ˆç° JSON å“åº”ã€‚
type Context struct {
    //åˆå§‹ç»“æ„
	writermem responseWriter//å­˜å‚¨http.ResponseWriterç­‰ä¿¡æ¯
	Request   *http.Request//http.Requestä¿¡æ¯
	Writer    ResponseWriter//å­˜å‚¨http.ResponseWriterçš„ç›¸å…³æ¥å£

	Params   Params
	handlers HandlersChain
	index    int8
	fullPath string

	engine *Engine
	params *Params

	// è¿™ä¸ªäº’æ–¥é”ä¿æŠ¤å¯†é’¥æ˜ å°„
	mu sync.RWMutex

	// Keys æ˜¯ä¸“é—¨ç”¨äºæ¯ä¸ªè¯·æ±‚ä¸Šä¸‹æ–‡çš„é”®/å€¼å¯¹ã€‚
	Keys map[string]interface{}

	// Errors æ˜¯é™„åŠ åˆ°æ‰€æœ‰ä½¿ç”¨æ­¤ä¸Šä¸‹æ–‡çš„å¤„ç†ç¨‹åº/ä¸­é—´ä»¶çš„é”™è¯¯åˆ—è¡¨ã€‚
	Errors errorMsgs

	// Accepted å®šä¹‰äº†æ‰‹åŠ¨æ¥å—çš„å†…å®¹åå•†æ ¼å¼åˆ—è¡¨ã€‚
	Accepted []string

	// queryCache ä½¿ç”¨ url.ParseQuery ç¼“å­˜æ¥è‡ª c.Request.URL.Query() çš„ param æŸ¥è¯¢ç»“æœ
	queryCache url.Values

// formCache ä½¿ç”¨ url.ParseQuery ç¼“å­˜ PostForm åŒ…å«ä» POSTã€PATCHã€
// æˆ– PUT ä¸»ä½“å‚æ•°ã€‚
	formCache url.Values

	// SameSite å…è®¸æœåŠ¡å™¨å®šä¹‰ cookie å±æ€§ï¼Œä½¿å…¶æ— æ³•
// æµè§ˆå™¨å°†æ­¤ cookie ä¸è·¨ç«™ç‚¹è¯·æ±‚ä¸€èµ·å‘é€ã€‚
	sameSite http.SameSite
}
```

Contextå¯¹è±¡å®šä¹‰çš„å­—æ®µçœŸçš„æ˜¯å¤ªå¤šäº†ï¼Œä¹Ÿä¸æ¸…æ¥šä½œç”¨éƒ½æ˜¯å•¥ï¼Ÿ

å…ˆåˆ«ç€æ€¥ï¼Œæˆ‘ä»¬å¾€åçœ‹ï¼Œçœ‹ä»–çš„æ¥å£ï¼Œå°±ä¼šæ˜ç™½ä»–çš„è¿™äº›å­—æ®µçš„ä½œç”¨æ˜¯å“ªäº›äº†ï¼ï¼ï¼ğŸ˜ğŸ˜ğŸ˜

å½“ä½ è¿›å…¥`context.go`æ–‡ä»¶é‡Œé¢ï¼Œå‘ç°é™¤äº†å®šä¹‰äº†ä¸€ä¸ªContextå¯¹è±¡æ—¶å€™ï¼Œå…¶ä»–çš„éƒ½æ˜¯æ¥å£ï¼Œç‰¹åˆ«å¤šï¼Œå·²ç»è¾¾åˆ°äº†ä¸Šåƒè¡Œã€‚

ä½ éœ€è¦æ˜ç™½æˆ‘ä»¬æ­¤è¡Œçš„ç›®çš„æ˜¯å»çœ‹**æˆ‘ä»¬åœ¨åˆ©ç”¨`gin`æ¡†æ¶å†™åç«¯ä»£ç æ—¶å€™å¸¸ç”¨çš„ä¸€äº›æ¥å£å‡½æ•°**

### æ„é€ å‡½æ•°

```go
/************************************/
/********** ä¸Šä¸‹æ–‡åˆ›å»º********/
/************************************/

func (c *Context) reset() {
	c.Writer = &c.writermem
	c.Params = c.Params[0:0]
	c.handlers = nil
	c.index = -1

	c.fullPath = ""
	c.Keys = nil
	c.Errors = c.Errors[0:0]
	c.Accepted = nil
	c.queryCache = nil
	c.formCache = nil
	*c.params = (*c.params)[0:0]
}
```

è¿™ä¸ªå¥½åƒæ˜¯ä¸Šä¸‹æ–‡çš„æ„é€ å‡½æ•°ï¼Œå¯æ˜¯æˆ‘ä»¬å†å†™`HandlerFunc` æ ¹æœ¬æ²¡æœ‰åˆ›å»ºè¿‡ï¼Œéƒ½æ˜¯ç›´æ¥å½“ä½œå‚æ•°å»ä½¿ç”¨ï¼Œé‚£ä¹ˆä»–åœ¨å“ªå„¿å»è°ƒç”¨å‘¢ï¼Ÿ

Contextçš„ä¸»è¦ä½œç”¨æ˜¯

* ç®€åŒ–æ„é€ ä¸€ä¸ªå®Œæ•´å“åº”çš„è¿‡ç¨‹
* è·¯ç”±çš„å¤„ç†å‡½æ•°ï¼Œä»¥åŠå°†è¦å®ç°çš„ä¸­é—´ä»¶ï¼Œå‚æ•°éƒ½ç»Ÿä¸€ä½¿ç”¨ Context å®ä¾‹ï¼Œ

è¿™äº›ä½œç”¨å¥½åƒéƒ½å»ºç«‹åœ¨æˆ‘å‘èµ·ä¸€ä¸ªè¯·æ±‚ï¼Œç„¶åæ‰ä¼šä½“ç°å‡ºæ¥çš„ã€‚

åœ¨ä¹‹å‰ä¸€ç¯‡çš„ã€Šginæ˜¯å¦‚ä½•è¿è¡Œçš„ã€‹æ–‡ç« é‡Œé¢ï¼ŒçŸ¥é“äº†ä¸€ä¸ªé‡è¦çš„å› ç´ 

> åªè¦ä¼ å…¥ä»»ä½•å®ç°äº†ServeHTTPæ¥å£çš„å®ä¾‹ï¼Œæ‰€æœ‰HTTPçš„è¯·æ±‚ï¼Œå°±éƒ½äº¤ç»™äº†è¯¥å®ä¾‹å»å¤„ç†ã€‚

æ‰€ä»¥Contextè¿™ä¸ªå¯¹è±¡çš„æ„å»ºä¼šä¸ä¼šåœ¨ServerHTTPè¿™ä¸ªæ¥å£é‡Œé¢å•Šï¼Ÿ

æˆ‘ä»¬å†æ¥çœ‹çœ‹è¿™ä¸ªServerHTTPçš„æ¥å£

```go
// ServeHTTP conforms to the http.Handler interface.
func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    //ä»æ± å­ä¸­å»ºç«‹ä¸€ä¸ªç©ºç™½çš„Contextå¯¹è±¡
	c := engine.pool.Get().(*Context)
    //åˆå§‹åŒ–responseWriterçš„http.ResponseWriterå’Œå†…å®¹å¤§å°ï¼ˆ-1ï¼‰é»˜è®¤è¿”å›ç 
	c.writermem.reset(w)
    //åˆå§‹åŒ–Contextçš„Request
	c.Request = req
    //æ„é€ å‡½æ•°
	c.reset()

	engine.handleHTTPRequest(c)
	//é‡Šæ”¾åˆšæ‰å»ºç«‹çš„c
	engine.pool.Put(c)
}
```

åœ¨è¿™é‡Œæˆ‘ä»¬æ˜ç™½äº†ï¼ŒContextçš„ä¸€äº›å­—æ®µçš„ä½œç”¨

* `writermem`
  * å­˜å‚¨`http.ResponseWriter`ä»¥åŠå†…å®¹å¤§å°å’Œè¿”å›ç 
* `Request`
  * å­˜å‚¨`http.Request`ä¿¡æ¯
* `Writer`
  * `ResponseWriter`ç›¸å…³æ¥å£

### è·å–å‚æ•°

å¸¸ç”¨çš„è·å–å‚æ•°å‡½æ•°

* `c.Query` è·å–querystringå‚æ•°
* `c.PostForm` è·å–formè¡¨å•å‚æ•°æ•°æ®
* ` c.GetRawData` è·å–jsonæ ¼å¼æ•°æ®
* `c.Param` è·å–pathå‚æ•°

`c.Query` 

```go
// Query returns the keyed url query value if it exists,
// otherwise it returns an empty string `("")`.
// It is shortcut for `c.Request.URL.Query().Get(key)`
//     GET /path?id=1234&name=Manu&value=
// 	   c.Query("id") == "1234"
// 	   c.Query("name") == "Manu"
// 	   c.Query("value") == ""
// 	   c.Query("wtf") == ""
func (c *Context) Query(key string) string {
	value, _ := c.GetQuery(key)
	return value
}
```

æ ¹æ®æ³¨é‡Šæ¥çœ‹ï¼Œæˆ‘ä»¬å†™çš„`Query` å¯ä»¥ç­‰ä»·äº`c.Request.URL.Query().Get(key)` åœ¨å¯ä»¥ç­‰ä»·äº`http.Request.URL.Query().Get(key)`

ä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·å­ç­‰ä»·å‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹ä¸‹é¢çš„ä»£ç 

```go
func (c *Context) initQueryCache() {
	if c.queryCache == nil {
		if c.Request != nil {
			c.queryCache = c.Request.URL.Query()
		} else {
			c.queryCache = url.Values{}
		}
	}
}
```

è¯´åˆ°æœ€åä»–æ˜¯åˆ©ç”¨åŸç”Ÿçš„æ–¹å¼è·å–Queryç„¶åå­˜å‚¨åœ¨`queryCache`è¿™ä¸ªå­—æ®µé‡Œé¢

```go
// GetQueryArray returns a slice of strings for a given query key, plus
// a boolean value whether at least one value exists for the given key.
func (c *Context) GetQueryArray(key string) ([]string, bool) {
	c.initQueryCache()
	if values, ok := c.queryCache[key]; ok && len(values) > 0 {
		return values, true
	}
	return []string{}, false
}
```

ç„¶åé€šè¿‡keyæ‹¿åˆ°`queryCache` é‡Œé¢çš„å…ƒç´ 

é€šè¿‡ä»¥ä¸Šè¿‡ç¨‹çš„çŒœæµ‹ï¼Œ`queryCache`æ˜¯ä¸€ä¸ªmapç±»å‹çš„ã€‚

æœ€åå‘ç°ç¡®å®å¦‚æ­¤`type Values map[string][]string`

è‡³äºæœ€åæ€ä¹ˆæ‹¿åˆ°Queryçš„å‚æ•°ï¼Œå»ºè®®å»çœ‹åŸç”Ÿåº“çš„å®ç°ï¼ï¼

`c.PostForm` 

è¿™ä¸ªå®ç°å’Œä¸Šé¢çš„`c.Query`ä¸€æ ·çš„è¿‡ç¨‹ã€‚è´´ä¸€äº›é‡è¦çš„ä»£ç 

```go
func (c *Context) initFormCache() {
	if c.formCache == nil {
		c.formCache = make(url.Values)
		req := c.Request
        //é€šè¿‡åŸç”ŸParseMultipartFormå»è·å–postæäº¤çš„è¡¨å•å‚æ•°
        //c.engine.MaxMultipartMemoryé™åˆ¶æå–çš„æœ€å¤§ä½“ç§¯
        //c.engine.MaxMultipartMemory=defaultMultipartMemory = 32 << 20 // 32 MB
		if err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {
			if err != http.ErrNotMultipart {
				debugPrint("error on parse multipart form array: %v", err)
			}
		}
		c.formCache = req.PostForm
	}
}
```

` c.GetRawData`

ä»–å¯èƒ½å°±æ¯”è¾ƒç®€å•äº†å°±ç›´æ¥è¯»å–bodyå†…éƒ¨çš„å†…å®¹ä¿¡æ¯

```go
// GetRawData return stream data.
func (c *Context) GetRawData() ([]byte, error) {
	return ioutil.ReadAll(c.Request.Body)
}
```

æˆ‘ä»¬é¡ºä¾¿å¯ä»¥çœ‹çœ‹`ReadAll()`å¦‚ä½•å®ç°çš„

```go
func ReadAll(r Reader) ([]byte, error) {
	b := make([]byte, 0, 512)
	for {
		if len(b) == cap(b) {
			// Add more capacity (let append pick how much).
			b = append(b, 0)[:len(b)]
		}
		n, err := r.Read(b[len(b):cap(b)])
		b = b[:len(b)+n]
		if err != nil {
			if err == EOF {
				err = nil
			}
			return b, err
		}
	}
}
```

è¿™ä¸ªå‡½æ•°ä¸»è¦è¡¨è¾¾çš„æ˜¯æˆ‘ä¸æ–­è¯»å–ä¿¡æ¯ï¼Œç›´åˆ°æˆ‘è¯»åˆ°é”™è¯¯æˆ–è€…EOFæˆ‘å°±ä¼šè¿”å›æ•°æ®å’Œerrã€‚å½“æˆ‘æˆåŠŸè¯»å®Œæ—¶å€™æ˜¯err=nilï¼Œå½“æˆ‘è¯»åˆ°EOFï¼Œæˆ‘ä¸ä¼šå»è¯»å–çš„EOFä½œä¸ºè¦è¿”å›çš„é”™è¯¯

`c.Param`

```go
// Param returns the value of the URL param.
// It is a shortcut for c.Params.ByName(key)
//     router.GET("/user/:id", func(c *gin.Context) {
//         // a GET request to /user/john
//         id := c.Param("id") // id == "john"
//     })
func (c *Context) Param(key string) string {
	return c.Params.ByName(key)
}
```

çœŸæ­£çš„æ ¸å¿ƒä»£ç 

```go
// Param æ˜¯å•ä¸ª URL å‚æ•°ï¼Œç”±é”®å’Œå€¼ç»„æˆã€‚ 
type Param struct {
	Key   string
	Value string
}

// Params is a Param-slice, as returned by the router.
// The slice is ordered, the first URL parameter is also the first slice value.
// It is therefore safe to read values by the index.
type Params []Param

// Get è¿”å›ä¸ç»™å®šåç§°åŒ¹é…çš„ç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼ã€‚
// å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„Paramï¼Œåˆ™è¿”å›ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ã€‚
func (ps Params) Get(name string) (string, bool) {
	for _, entry := range ps {
		if entry.Key == name {
			return entry.Value, true
		}
	}
	return "", false
}
```

å½“ä½ å‘èµ·è¯·æ±‚æ—¶å€™ä»–ä¼šå°†URLçš„å‚æ•°è¿›è¡Œåˆ†è§£ï¼Œå­˜å‚¨åœ¨[]Paramè¿™ä¸ªåˆ‡ç‰‡é‡Œé¢ï¼Œç„¶åä»ä¸­å–å€¼ã€‚

è‡³äºä»–æ€ä¹ˆå»è¿›è¡Œåˆ†è§£ï¼Œç­‰è®²åˆ°è·¯ç”±å†è¯´ï¼

å…¶å®ï¼Œæˆ‘å†™é¡¹ç›®ä¸€èˆ¬éƒ½æ˜¯ç”¨çš„æ˜¯

* `ShouldBind`
* `ShouldBindJSON`

ä¼šä»£æ›¿ä¸Šé¢ä¸€éƒ¨åˆ†çš„å‡½æ•°ã€‚

å…¶å®è¿™äº›`ShouldBind`è¿™ç±»å‡½æ•°éƒ½æ˜¯ginå†…ç½®äº†åº“(https://github.com/go-playground/validator)è¿›è¡Œå°è£…çš„

æ ¸å¿ƒä»£ç 

```go
func (c *Context) ShouldBind(obj interface{}) error {
	b := binding.Default(c.Request.Method, c.ContentType())
	return c.ShouldBindWith(obj, b)
}
var JSON          = jsonBinding{}
// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).
func (c *Context) ShouldBindJSON(obj interface{}) error {
	return c.ShouldBindWith(obj, binding.JSON)
}
func (c *Context) ShouldBindWith(obj interface{}, b binding.Binding) error {
	return b.Bind(c.Request, obj)
}
//ç›¸å…³æ¥å£ä¸å®ç°çš„å‡½æ•°
type Binding interface {
	Name() string
	Bind(*http.Request, interface{}) error
}
func (jsonBinding) Bind(req *http.Request, obj interface{}) error {
	if req == nil || req.Body == nil {
		return fmt.Errorf("invalid request")
	}
    //æ£€éªŒjsonæœ€ååˆ©ç”¨å°±æ˜¯validatoråº“è¿›è¡Œæ£€éªŒ
	return decodeJSON(req.Body, obj)
}
```

æ„Ÿè§‰å¾ˆç‰›ï¼ï¼ï¼ğŸŠğŸŠğŸŠ

### è¿”å›ä½“ç±»å‹

å…¶å®ä¸€èˆ¬å“åº”éƒ½æ˜¯ç”¨çš„`c.JSON` (å› ä¸ºæˆ‘åšçš„å‰åç«¯åˆ†ç¦»çš„å˜¿å˜¿ï¼ï¼ï¼)

æ ¸å¿ƒä»£ç ï¼š

```go
// JSON å°†ç»™å®šçš„ç»“æ„ä½œä¸º JSON åºåˆ—åŒ–åˆ°å“åº”æ­£æ–‡ä¸­ã€‚
// It also sets the Content-Type as "application/json".
func (c *Context) JSON(code int, obj interface{}) {
	c.Render(code, render.JSON{Data: obj})
}
// Render writes the response headers and calls render.Render to render data.
func (c *Context) Render(code int, r render.Render) {
    //è®¾ç½®çŠ¶æ€ç 
	c.Status(code)
	//æ£€æµ‹çŠ¶æ€ç 
	if !bodyAllowedForStatus(code) {
		r.WriteContentType(c.Writer)
		c.Writer.WriteHeaderNow()
		return
	}
	//è¿”å›ä½“å†™å…¥ä¿¡æ¯
	if err := r.Render(c.Writer); err != nil {
		panic(err)
	}
}
//jsonå®ç°çš„æ–¹æ³•
func (r JSON) Render(w http.ResponseWriter) (err error) {
	if err = WriteJSON(w, r.Data); err != nil {
		panic(err)
	}
	return
}
// WriteJSON marshals the given interface object and writes it with custom ContentType.
func WriteJSON(w http.ResponseWriter, obj interface{}) error {
    //sets the Content-Type as "application/json".
	writeContentType(w, jsonContentType)
	jsonBytes, err := json.Marshal(obj)
	if err != nil {
		return err
	}
	_, err = w.Write(jsonBytes)
	return err
}
```

è¿™äº›ä»£ç æœ€åçš„ç»“æœéƒ½æ˜¯è®²jsonä¸­çš„dataæ•°æ®å†™å…¥responseä¸­

ä¸ºä»€ä¹ˆè¯´æ˜¯åœ¨responseç»“æ„ä½“é‡Œé¢ï¼Ÿ

> è¯·çœ‹åšå®¢ï¼šhttps://cloud.tencent.com/developer/article/1634278

### ä¸­é—´ä»¶

æ ¸å¿ƒä»£ç ï¼š

```go
func (c *Context) Next() {
	c.index++
	for c.index < int8(len(c.handlers)) {
		c.handlers[c.index](c)
		c.index++
	}
}
```

